
R version 3.5.1 Patched (2018-07-24 r75008) -- "Feather Spray"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "distrMod"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('distrMod')
Loading required package: distr
Loading required package: startupmsg
:startupmsg>  Utilities for Start-Up Messages (version 0.9.5)
:startupmsg> 
:startupmsg>  For more information see ?"startupmsg",
:startupmsg>  NEWS("startupmsg")

Loading required package: sfsmisc
:distr>  Object Oriented Implementation of Distributions (version
:distr>  2.7.0)
:distr> 
:distr>  Attention: Arithmetics on distribution objects are
:distr>  understood as operations on corresponding random variables
:distr>  (r.v.s); see distrARITH().
:distr> 
:distr>  Some functions from package 'stats' are intentionally masked
:distr>  ---see distrMASK().
:distr> 
:distr>  Note that global options are controlled by distroptions()
:distr>  ---c.f. ?"distroptions".
:distr> 
:distr>  For more information see ?"distr", NEWS("distr"), as well as
:distr>    http://distr.r-forge.r-project.org/
:distr>  Package "distrDoc" provides a vignette to this package as
:distr>  well as to several extension packages; try
:distr>  vignette("distr").


Attaching package: ‘distr’

The following objects are masked from ‘package:stats’:

    df, qqplot, sd

Loading required package: distrEx
:distrEx>  Extensions of Package 'distr' (version 2.7.0)
:distrEx> 
:distrEx>  Note: Packages "e1071", "moments", "fBasics" should be
:distrEx>  attached /before/ package "distrEx". See
:distrEx>  distrExMASK().Note: Extreme value distribution
:distrEx>  functionality has been moved to
:distrEx> 
:distrEx>        package "RobExtremes". See distrExMOVED().
:distrEx> 
:distrEx>  For more information see ?"distrEx", NEWS("distrEx"), as
:distrEx>  well as
:distrEx>    http://distr.r-forge.r-project.org/
:distrEx>  Package "distrDoc" provides a vignette to this package
:distrEx>  as well as to several related packages; try
:distrEx>  vignette("distr").


Attaching package: ‘distrEx’

The following objects are masked from ‘package:stats’:

    IQR, mad, median, var

Loading required package: RandVar
:RandVar>  Implementation of Random Variables (version 1.0.1)
:RandVar> 
:RandVar>  For more information see ?"RandVar", NEWS("RandVar"), as
:RandVar>  well as
:RandVar>    http://robast.r-forge.r-project.org/
:RandVar>  This package also includes a vignette; try
:RandVar>  vignette("RandVar").

Loading required package: MASS
Loading required package: stats4
:distrMod>  Object Oriented Implementation of Probability Models
:distrMod>  (version 2.7.0)
:distrMod> 
:distrMod>  Some functions from pkg's 'base' and 'stats' are
:distrMod>  intentionally masked ---see distrModMASK().
:distrMod> 
:distrMod>  Note that global options are controlled by
:distrMod>  distrModoptions() ---c.f. ?"distrModoptions".
:distrMod> 
:distrMod>  For more information see ?"distrMod",
:distrMod>  NEWS("distrMod"), as well as
:distrMod>    http://distr.r-forge.r-project.org/
:distrMod>  There is a vignette to this package; try
:distrMod>  vignette("distrMod").
:distrMod>  Package "distrDoc" provides a vignette to the other
:distrMod>  distrXXX packages,
:distrMod>  as well as to several related packages; try
:distrMod>  vignette("distr").


Attaching package: ‘distrMod’

The following object is masked from ‘package:stats4’:

    confint

The following object is masked from ‘package:stats’:

    confint

The following object is masked from ‘package:base’:

    norm

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("BetaFamily")
> ### * BetaFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: BetaFamily
> ### Title: Generating function for Beta families
> ### Aliases: BetaFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (B1 <- BetaFamily())
An object of class "BetaFamily"
### name:	Beta family

### distribution:	Distribution Object of Class: Beta
 shape1: 1
 shape2: 1
 ncp: 0

### param:	An object of class "ParamFamParameter"
name:	shape1 and shape2
shape1:	1
shape2:	1
trafo:
       shape1 shape2
shape1      1      0
shape2      0      1

### props:
[1] "The Beta family is invariant in the following sense"
[2] "if (x_i)~Beta(s1,s2) then (1-x_i)~Beta(s2,s1)"      
> FisherInfo(B1)
An object of class "PosSemDefSymmMatrix"
           shape1     shape2
shape1  1.0000000 -0.6449341
shape2 -0.6449341  1.0000000
> checkL2deriv(B1)
precision of centering:	 3.96327e-05 3.963591e-05 
precision of Fisher information:
              shape1        shape2
shape1 -1.851068e-05  1.648326e-06
shape2  1.648326e-06 -1.851068e-05
precision of Fisher information - relativ error [%]:
              shape1        shape2
shape1 -0.0018510679 -0.0002555806
shape2 -0.0002555806 -0.0018510679
condition of Fisher information:
[1] 5.277691
$maximum.deviation
[1] 3.963591e-05

> 
> 
> 
> cleanEx()
> nameEx("BiasType-class")
> ### * BiasType-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: BiasType-class
> ### Title: Bias Type
> ### Aliases: BiasType-class name,BiasType-method name<-,BiasType-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> aB <- positiveBias()
> name(aB)
[1] "positive Bias"
> 
> 
> 
> cleanEx()
> nameEx("BinomFamily")
> ### * BinomFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: BinomFamily
> ### Title: Generating function for Binomial families
> ### Aliases: BinomFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (B1 <- BinomFamily(size = 25, prob = 0.25))
An object of class "BinomFamily"
### name:	Binomial family

### distribution:	Distribution Object of Class: Binom
 size: 25
 prob: 0.25

### param:	An object of class "ParamFamParameter"
name:	probability of success
prob:	0.25
fixed part of param.:
	size:	25
trafo:
     prob
prob    1

### props:
[1] "The Binomial family is symmetric with respect to prob = 0.5;"
[2] "i.e., d(Binom(size, prob))(k)=d(Binom(size,1-prob))(size-k)" 
> plot(B1)
> FisherInfo(B1)
An object of class "PosSemDefSymmMatrix"
         prob
prob 133.3333
> checkL2deriv(B1)
precision of centering:	 -1.099042e-15 
precision of Fisher information:
             prob
prob 2.842171e-14
precision of Fisher information - relativ error [%]:
             prob
prob 2.131628e-14
condition of Fisher information:
[1] 1
$maximum.deviation
[1] 2.842171e-14

> 
> 
> 
> cleanEx()
> nameEx("CauchyLocationScaleFamily")
> ### * CauchyLocationScaleFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CauchyLocationScaleFamily
> ### Title: Generating function for Cauchy location and scale families
> ### Aliases: CauchyLocationScaleFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (C1 <- CauchyLocationScaleFamily())
An object of class "CauchyLocationScaleFamily"
### name:	Cauchy Location and scale family

### distribution:	Distribution Object of Class: Cauchy
 location: 0
 scale: 1

### param:	An object of class "ParamWithScaleFamParameter"
name:	location and scale
loc:	0
scale:	1
trafo:
      loc scale
loc     1     0
scale   0     1

### props:
[1] "The Cauchy Location and scale family is invariant under"  
[2] "the group of transformations 'g(x) = scale*x + loc'"      
[3] "with location parameter 'loc' and scale parameter 'scale'"
> plot(C1)
> FisherInfo(C1)
An object of class "PosDefSymmMatrix"
      loc scale
loc   0.5   0.0
scale 0.0   0.5
> ### need smaller integration range:
> distrExoptions("ElowerTruncQuantile"=1e-4,"EupperTruncQuantile"=1e-4)
> checkL2deriv(C1)
precision of centering:	 0 -0.02119711 
precision of Fisher information:
                loc       scale
loc   -3.137524e-05  0.00000000
scale  0.000000e+00 -0.02118143
precision of Fisher information - relativ error [%]:
               loc     scale
loc   -0.006275047       NaN
scale          NaN -4.236286
condition of Fisher information:
[1] 1
$maximum.deviation
[1] 0.02119711

> distrExoptions("ElowerTruncQuantile"=1e-7,"EupperTruncQuantile"=1e-7)
> 
> 
> 
> cleanEx()
> nameEx("Confint-class")
> ### * Confint-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Confint-class
> ### Title: Confint-class
> ### Aliases: Confint-class type,Confint-method call.estimate
> ###   call.estimate,Confint-method confint,Confint,missing-method
> ###   name.estimate name.estimate,Confint-method trafo.estimate
> ###   trafo.estimate,Confint-method samplesize.estimate
> ###   samplesize.estimate,Confint-method completecases.estimate
> ###   completecases.estimate,Confint-method nuisance.estimate
> ###   nuisance.estimate,Confint-method fixed.estimate
> ###   fixed.estimate,Confint-method show,Confint-method
> ###   print,Confint-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## some transformation
> mtrafo <- function(x){
+      nms0 <- c("scale","shape")
+      nms <- c("shape","rate")
+      fval0 <- c(x[2], 1/x[1])
+      names(fval0) <- nms
+      mat0 <- matrix( c(0, -1/x[1]^2, 1, 0), nrow = 2, ncol = 2,
+                      dimnames = list(nms,nms0))                          
+      list(fval = fval0, mat = mat0)}
> 
> x <- rgamma(50, scale = 0.5, shape = 3)
> 
> ## parametric family of probability measures
> G <- GammaFamily(scale = 1, shape = 2, trafo = mtrafo)
> ## MLE
> res <- MLEstimator(x = x, ParamFamily = G)
> ci <- confint(res)
> print(ci, digits = 4, show.details="maximal")
A[n] asymptotic (CLT-based) confidence interval:
      2.5 % 97.5 %
shape 2.530  5.591
rate  1.751  4.097
Type of estimator: Maximum likelihood estimate
samplesize:   50
Call by which estimate was produced:
MLEstimator(x = x, ParamFamily = G)
Transformation of main parameter by which estimate was produced:
function (x) 
{
    nms0 <- c("scale", "shape")
    nms <- c("shape", "rate")
    fval0 <- c(x[2], 1/x[1])
    names(fval0) <- nms
    mat0 <- matrix(c(0, -1/x[1]^2, 1, 0), nrow = 2, ncol = 2, 
        dimnames = list(nms, nms0))
    list(fval = fval0, mat = mat0)
}
<bytecode: 0x9e38338>
Trafo / derivative matrix at which estimate was produced:
       scale shape
shape  0.000     1
rate  -8.549     0
> print(ci, digits = 4, show.details="medium")
A[n] asymptotic (CLT-based) confidence interval:
      2.5 % 97.5 %
shape 2.530  5.591
rate  1.751  4.097
Type of estimator: Maximum likelihood estimate
samplesize:   50
Call by which estimate was produced:
MLEstimator(x = x, ParamFamily = G)
> print(ci, digits = 4, show.details="minimal")
A[n] asymptotic (CLT-based) confidence interval:
      2.5 % 97.5 %
shape 2.530  5.591
rate  1.751  4.097
> 
> 
> 
> cleanEx()
> nameEx("Estimate-class")
> ### * Estimate-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Estimate-class
> ### Title: Estimate-class.
> ### Aliases: Estimate-class name,Estimate-method name<-,Estimate-method
> ###   estimate estimate,Estimate-method estimate.call
> ###   estimate.call,Estimate-method Infos Infos,Estimate-method samplesize
> ###   samplesize,Estimate-method completecases
> ###   completecases,Estimate-method asvar asvar,Estimate-method
> ###   fixed,Estimate-method asvar<- asvar<-,Estimate-method
> ###   nuisance,Estimate-method main,Estimate-method Infos<-
> ###   Infos<-,Estimate-method addInfo<- addInfo<-,Estimate-method
> ###   show,Estimate-method print,Estimate-method untransformed.estimate
> ###   untransformed.estimate,Estimate-method untransformed.asvar
> ###   untransformed.asvar,Estimate-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> x <- rnorm(100)
> Estimator(x, estimator = mean, name = "mean")
Evaluations of mean:
--------------------
An object of class “Estimate” 
generated by call
  Estimator(x = x, estimator = mean, name = "mean")
samplesize:   100
estimate:
    mean1 
0.1088874 
> 
> x1 <- x; x1[sample(1:100,10)] <- NA
> myEst1 <- Estimator(x1, estimator = mean, name = "mean")
> samplesize(myEst1)
[1] 90
> samplesize(myEst1, onlycomplete = FALSE)
[1] 100
> 
> 
> 
> cleanEx()
> nameEx("Estimator")
> ### * Estimator
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Estimator
> ### Title: Function to compute estimates
> ### Aliases: Estimator
> ### Keywords: univar
> 
> ### ** Examples
> 
> x <- rnorm(100)
> Estimator(x, estimator = mean, name = "mean")
Evaluations of mean:
--------------------
An object of class “Estimate” 
generated by call
  Estimator(x = x, estimator = mean, name = "mean")
samplesize:   100
estimate:
    mean1 
0.1088874 
> 
> X <- matrix(rnorm(1000), nrow = 10)
> Estimator(X, estimator = rowMeans, name = "mean")
Evaluations of mean:
--------------------
An object of class “Estimate” 
generated by call
  Estimator(x = X, estimator = rowMeans, name = "mean")
samplesize:   100
estimate:
  rowMeans1   rowMeans2   rowMeans3   rowMeans4   rowMeans5   rowMeans6 
-0.10612810  0.22309674 -0.01146361 -0.20224815  0.08660978 -0.13837167 
  rowMeans7   rowMeans8   rowMeans9  rowMeans10 
-0.03214991 -0.02971528 -0.13027892  0.10496336 
> 
> 
> 
> cleanEx()
> nameEx("EvenSymmetric-class")
> ### * EvenSymmetric-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: EvenSymmetric-class
> ### Title: Class for Even Functions
> ### Aliases: EvenSymmetric-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("EvenSymmetric")
type of symmetry:	even function
center of symmetry:
numeric(0)
> 
> 
> 
> cleanEx()
> nameEx("EvenSymmetric")
> ### * EvenSymmetric
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: EvenSymmetric
> ### Title: Generating function for EvenSymmetric-class
> ### Aliases: EvenSymmetric
> ### Keywords: math
> 
> ### ** Examples
> 
> EvenSymmetric()
type of symmetry:	even function
center of symmetry:
[1] 0
> 
> ## The function is currently defined as
> function(SymmCenter = 0){ 
+     new("EvenSymmetric", SymmCenter = SymmCenter) 
+ }
function (SymmCenter = 0) 
{
    new("EvenSymmetric", SymmCenter = SymmCenter)
}
> 
> 
> 
> cleanEx()
> nameEx("ExpScaleFamily")
> ### * ExpScaleFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ExpScaleFamily
> ### Title: Generating function for exponential scale families
> ### Aliases: ExpScaleFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (E1 <- ExpScaleFamily())
An object of class "ExpScaleFamily"
### name:	Exponential scale family

### distribution:	Distribution Object of Class: Exp
 rate: 1
Warning in show(x) :
  arithmetics on distributions are understood as operations on r.v.'s
see 'distrARITH()'; for switching off this warning see '?distroptions'

### param:	An object of class "ParamWithScaleFamParameter"
name:	scale
scale:	1
trafo:
      scale
scale     1

### props:
[1] "The Exponential scale family is invariant under"
[2] "the group of transformations 'g(y) = scale*y'"  
[3] "with scale parameter 'scale'"                   
> plot(E1)
> Map(L2deriv(E1)[[1]])
[[1]]
function (x) 
{
    ((x - 0)/c(scale = 1) * LogDeriv((x - 0)/c(scale = 1)) - 
        1)/c(scale = 1)
}
<environment: 0xaf2fcb8>

> checkL2deriv(E1)
precision of centering:	 -1.51181e-06 
precision of Fisher information:
             scale
scale -2.61793e-05
precision of Fisher information - relativ error [%]:
            scale
scale -0.00261793
condition of Fisher information:
[1] 1
$maximum.deviation
[1] 2.61793e-05

> 
> 
> 
> cleanEx()
> nameEx("FunSymmList-class")
> ### * FunSymmList-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: FunSymmList-class
> ### Title: List of Symmetries for a List of Functions
> ### Aliases: FunSymmList-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("FunSymmList", list(NonSymmetric(), EvenSymmetric(SymmCenter = 1), 
+                         OddSymmetric(SymmCenter = 2)))
An object of class "FunSymmList"
[[1]]
type of symmetry:	non-symmetric function
NULL

[[2]]
type of symmetry:	even function
center of symmetry:
[1] 1

[[3]]
type of symmetry:	odd function
center of symmetry:
[1] 2

> 
> 
> 
> cleanEx()
> nameEx("FunSymmList")
> ### * FunSymmList
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: FunSymmList
> ### Title: Generating function for FunSymmList-class
> ### Aliases: FunSymmList
> ### Keywords: math
> 
> ### ** Examples
> 
> FunSymmList(NonSymmetric(), EvenSymmetric(SymmCenter = 1), 
+             OddSymmetric(SymmCenter = 2))
An object of class "FunSymmList"
[[1]]
type of symmetry:	non-symmetric function
NULL

[[2]]
type of symmetry:	even function
center of symmetry:
[1] 1

[[3]]
type of symmetry:	odd function
center of symmetry:
[1] 2

> 
> ## The function is currently defined as
> function (...){
+     new("FunSymmList", list(...))
+ }
function (...) 
{
    new("FunSymmList", list(...))
}
> 
> 
> 
> cleanEx()
> nameEx("GammaFamily")
> ### * GammaFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: GammaFamily
> ### Title: Generating function for Gamma families
> ### Aliases: GammaFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (G1 <- GammaFamily())
An object of class "GammaFamily"
### name:	Gamma family

### distribution:	Distribution Object of Class: Gammad
 shape: 1
 scale: 1

### param:	An object of class "ParamFamParameter"
name:	scale and shape
scale:	1
shape:	1
trafo:
      scale shape
scale     1     0
shape     0     1
Shape parameter must not be negative.

### props:
[1] "The Gamma family is scale invariant via the parametrization"
[2] "'(nu,shape)=(log(scale),shape)'"                            
> FisherInfo(G1)
An object of class "PosDefSymmMatrix"
      scale    shape
scale     1 1.000000
shape     1 1.644934
> checkL2deriv(G1)
precision of centering:	 -1.51181e-06 1.312514e-06 
precision of Fisher information:
              scale         shape
scale -2.617930e-05 -7.165188e-06
shape -7.165188e-06 -2.862712e-05
precision of Fisher information - relativ error [%]:
              scale         shape
scale -0.0026179301 -0.0007165188
shape -0.0007165188 -0.0017403202
condition of Fisher information:
[1] 10.60328
$maximum.deviation
[1] 2.862712e-05

> 
> 
> 
> cleanEx()
> nameEx("InfoNorm")
> ### * InfoNorm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: InfoNorm
> ### Title: Generating function for InfoNorm-class
> ### Aliases: InfoNorm
> ### Keywords: robust
> 
> ### ** Examples
> 
> InfoNorm()
An object of class "InfoNorm"
Slot "QuadForm":
An object of class "PosSemDefSymmMatrix"
     [,1]
[1,]    1

Slot "name":
[1] "Information matrix Norm"

Slot "fct":
function (x) 
QuadFormNorm(x, A = A)
<bytecode: 0xb13f8b0>
<environment: 0xb13f5a0>

> 
> ## The function is currently defined as
> function(){ new("InfoNorm") }
function () 
{
    new("InfoNorm")
}
> 
> 
> 
> cleanEx()
> nameEx("L2GroupFamily-class")
> ### * L2GroupFamily-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2GroupParamFamily-class
> ### Title: L2 differentiable parametric group family
> ### Aliases: L2GroupParamFamily-class LogDeriv
> ###   LogDeriv,L2GroupParamFamily-method LogDeriv<-
> ###   LogDeriv<-,L2GroupParamFamily-method
> ### Keywords: classes models
> 
> ### ** Examples
> 
> F1 <- new("L2GroupParamFamily")
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("L2LocationFamily-class")
> ### * L2LocationFamily-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2LocationFamily-class
> ### Title: L2 differentiable parametric group family
> ### Aliases: L2LocationFamily-class
> ### Keywords: classes models
> 
> ### ** Examples
> 
> F1 <- new("L2LocationFamily")
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("L2LocationFamily")
> ### * L2LocationFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2LocationFamily
> ### Title: Generating function for L2LocationFamily-class
> ### Aliases: L2LocationFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> F1 <- L2LocationFamily()
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("L2LocationScaleFamily-class")
> ### * L2LocationScaleFamily-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2LocationScaleFamily-class
> ### Title: L2 differentiable parametric group family
> ### Aliases: L2LocationScaleFamily-class
> ### Keywords: classes models
> 
> ### ** Examples
> 
> F1 <- new("L2LocationScaleFamily")
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("L2LocationScaleFamily")
> ### * L2LocationScaleFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2LocationScaleFamily
> ### Title: Generating function for L2LocationScaleFamily-class
> ### Aliases: L2LocationScaleFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> F1 <- L2LocationScaleFamily()
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("L2LocationUnknownScaleFamily")
> ### * L2LocationUnknownScaleFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2LocationUnknownScaleFamily
> ### Title: Generating function for L2LocationScaleFamily-class in nuisance
> ###   situation
> ### Aliases: L2LocationUnknownScaleFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> F1 <- L2LocationUnknownScaleFamily()
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("L2ParamFamily-class")
> ### * L2ParamFamily-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2ParamFamily-class
> ### Title: L2 differentiable parametric family
> ### Aliases: plot plot-methods L2ParamFamily-class FisherInfo
> ###   FisherInfo,L2ParamFamily,missing-method
> ###   FisherInfo,L2ParamFamily,ParamFamParameter-method L2deriv
> ###   L2deriv,L2ParamFamily,missing-method
> ###   L2deriv,L2ParamFamily,ParamFamParameter-method L2derivSymm
> ###   L2derivSymm,L2ParamFamily-method L2derivDistr
> ###   L2derivDistr,L2ParamFamily-method L2derivDistrSymm
> ###   L2derivDistrSymm,L2ParamFamily-method
> ###   checkL2deriv,L2ParamFamily-method
> ###   E,L2ParamFamily,EuclRandVariable,missing-method
> ###   E,L2ParamFamily,EuclRandMatrix,missing-method
> ###   E,L2ParamFamily,EuclRandVarList,missing-method
> ###   plot,L2ParamFamily,missing-method
> ### Keywords: classes models
> 
> ### ** Examples
> 
> F1 <- new("L2ParamFamily")
> plot(F1)
> 
> ## selection of subpanels for plotting
> F2 <- L2LocationScaleFamily()
> layout(matrix(c(1,2,3,3), nrow=2, byrow=TRUE))
> plot(F2,mfColRow = FALSE,
+      to.draw.arg=c("p","q","loc"))
> plot(F2,mfColRow = FALSE, inner=list("empirical cdf","pseudo-inverse",
+      "L2-deriv, loc.part"), to.draw.arg=c("p","q","loc"))
> 
> 
> 
> cleanEx()
> nameEx("L2ParamFamily")
> ### * L2ParamFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2ParamFamily
> ### Title: Generating function for L2ParamFamily-class
> ### Aliases: L2ParamFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> F1 <- L2ParamFamily()
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("L2ScaleFamily-class")
> ### * L2ScaleFamily-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2ScaleFamily-class
> ### Title: L2 differentiable parametric group family
> ### Aliases: L2ScaleFamily-class
> ### Keywords: classes models
> 
> ### ** Examples
> 
> F1 <- new("L2ScaleFamily")
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("L2ScaleFamily")
> ### * L2ScaleFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2ScaleFamily
> ### Title: Generating function for L2ScaleFamily-class
> ### Aliases: L2ScaleFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> F1 <- L2ScaleFamily()
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("L2ScaleUnknownLocationFamily")
> ### * L2ScaleUnknownLocationFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2ScaleUnknownLocationFamily
> ### Title: Generating function for L2LocationScaleFamily-class in nuisance
> ###   situation
> ### Aliases: L2ScaleUnknownLocationFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> F1 <- L2ScaleUnknownLocationFamily()
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("LnormScaleFamily")
> ### * LnormScaleFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LnormScaleFamily
> ### Title: Generating function for lognormal scale families
> ### Aliases: LnormScaleFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (L1 <- LnormScaleFamily())
An object of class "LnormScaleFamily"
### name:	lognormal scale family

### distribution:	Distribution Object of Class: Lnorm
 meanlog: 0
 sdlog: 1
Warning in show(x) :
  arithmetics on distributions are understood as operations on r.v.'s
see 'distrARITH()'; for switching off this warning see '?distroptions'

### param:	An object of class "ParamWithScaleFamParameter"
name:	scale
meanlog:	1
fixed part of param.:
	:	0
trafo:
      scale
scale     1

### props:
[1] "The lognormal scale family is invariant under"
[2] "the group of transformations 'g(y) = scale*y'"
[3] "with scale parameter 'scale'"                 
> plot(L1)
> Map(L2deriv(L1)[[1]])
[[1]]
function (x) 
{
    ((x - 0)/c(meanlog = 1) * LogDeriv((x - 0)/c(meanlog = 1)) - 
        1)/c(meanlog = 1)
}
<environment: 0x4396ab8>

> checkL2deriv(L1)
precision of centering:	 -0.003003394 
precision of Fisher information:
            meanlog
meanlog -0.01027919
precision of Fisher information - relativ error [%]:
          meanlog
meanlog -1.027919
condition of Fisher information:
[1] 1
$maximum.deviation
[1] 0.01027919

> 
> 
> 
> cleanEx()
> nameEx("MCEstimate-class")
> ### * MCEstimate-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCEstimate-class
> ### Title: MCEstimate-class.
> ### Aliases: MCEstimate-class criterion criterion,MCEstimate-method
> ###   criterion.fct criterion.fct,MCEstimate-method
> ###   startPar,MCEstimate-method method method,MCEstimate-method optimwarn
> ###   optimwarn,MCEstimate-method criterion<- criterion<-,MCEstimate-method
> ###   coerce,MCEstimate,mle-method show,MCEstimate-method
> ###   profile,MCEstimate-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## (empirical) Data
> x <- rgamma(50, scale = 0.5, shape = 3)
> 
> ## parametric family of probability measures
> G <- GammaFamily(scale = 1, shape = 2)
> 
> MDEstimator(x, G)
Evaluations of Minimum Kolmogorov distance estimate:
----------------------------------------------------
An object of class “Estimate” 
generated by call
  MDEstimator(x = x, ParamFamily = G)
samplesize:   50
estimate:
    scale     shape 
0.3398645 4.2654569 
Criterion:
Kolmogorov distance 
         0.06350364 
> (m <- MLEstimator(x, G))
Evaluations of Maximum likelihood estimate:
-------------------------------------------
An object of class “Estimate” 
generated by call
  MLEstimator(x = x, ParamFamily = G)
samplesize:   50
estimate:
     scale        shape   
  0.34200800   4.06028564 
 (0.07002713) (0.78099026)
asymptotic (co)variance (multiplied with samplesize):
           scale     shape
scale  0.2451899 -2.568863
shape -2.5688629 30.497289
Criterion:
negative log-likelihood 
                47.9651 
> m.mle <- as(m,"mle")
> par(mfrow=c(1,2))
> profileM <- profile(m)
> ## plot-profile throws an error
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("MCEstimator")
> ### * MCEstimator
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCEstimator
> ### Title: Function to compute minimum criterion estimates
> ### Aliases: MCEstimator
> ### Keywords: univar
> 
> ### ** Examples
> 
> ## (empirical) Data
> x <- rgamma(50, scale = 0.5, shape = 3)
> 
> ## parametric family of probability measures
> G <- GammaFamily(scale = 1, shape = 2)
> 
> ## Maximum Likelihood estimator
> ## Note: you can directly use function MLEstimator!
> negLoglikelihood <- function(x, Distribution){
+     res <- -sum(log(Distribution@d(x)))
+     names(res) <- "Negative Log-Likelihood"
+     return(res)
+ }
> MCEstimator(x = x, ParamFamily = G, criterion = negLoglikelihood)
Evaluations of Minimum criterion estimate:
------------------------------------------
An object of class “Estimate” 
generated by call
  MCEstimator(x = x, ParamFamily = G, criterion = negLoglikelihood)
samplesize:   50
estimate:
   scale    shape 
0.342008 4.060286 
Criterion:
        
47.9651 
> 
> ## Kolmogorov(-Smirnov) minimum distance estimator
> ## Note: you can also use function MDEstimator!
> MCEstimator(x = x, ParamFamily = G, criterion = KolmogorovDist, 
+             crit.name = "Kolmogorov distance")
Evaluations of Minimum Kolmogorov distance estimate:
----------------------------------------------------
An object of class “Estimate” 
generated by call
  MCEstimator(x = x, ParamFamily = G, criterion = KolmogorovDist, 
    crit.name = "Kolmogorov distance")
samplesize:   50
estimate:
    scale     shape 
0.3398645 4.2654569 
Criterion:
Kolmogorov distance 
         0.06350364 
> 
> ## Total variation minimum distance estimator
> ## Note: you can also use function MDEstimator!
> ## discretize Gamma distribution
> MCEstimator(x = x, ParamFamily = G, criterion = TotalVarDist, 
+             crit.name = "Total variation distance")
Evaluations of Minimum Total variation distance estimate:
---------------------------------------------------------
An object of class “Estimate” 
generated by call
  MCEstimator(x = x, ParamFamily = G, criterion = TotalVarDist, 
    crit.name = "Total variation distance")
samplesize:   50
estimate:
    scale     shape 
0.2829687 5.0197306 
Criterion:
Total variation distance 
               0.4866141 
> 
> ## or smooth empirical distribution (takes some time!)
> #MCEstimator(x = x, ParamFamily = G, criterion = TotalVarDist, 
> #            asis.smooth.discretize = "smooth", crit.name = "Total variation distance")
> 
> ## Hellinger minimum distance estimator
> ## Note: you can also use function MDEstimator!
> ## discretize Gamma distribution
> distroptions(DistrResolution = 1e-8)
> MCEstimator(x = x, ParamFamily = G, criterion = HellingerDist, 
+             crit.name = "Hellinger Distance", startPar = c(1,2))
Evaluations of Minimum Hellinger Distance estimate:
---------------------------------------------------
An object of class “Estimate” 
generated by call
  MCEstimator(x = x, ParamFamily = G, criterion = HellingerDist, 
    crit.name = "Hellinger Distance", startPar = c(1, 2))
samplesize:   50
estimate:
   scale    shape 
1.057442 1.683644 
Criterion:
Hellinger Distance 
         0.3782642 
> distroptions(DistrResolution = 1e-6)
> 
> ## or smooth empirical distribution (takes some time!)
> #MCEstimator(x = x, ParamFamily = G, criterion = HellingerDist, 
> #            asis.smooth.discretize = "smooth", crit.name = "Hellinger distance")
> 
> 
> 
> cleanEx()
> nameEx("MDEstimator")
> ### * MDEstimator
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MDEstimator
> ### Title: Function to compute minimum distance estimates
> ### Aliases: MDEstimator CvMMDEstimator KolmogorovMDEstimator
> ###   TotalVarMDEstimator HellingerMDEstimator
> ### Keywords: univar robust
> 
> ### ** Examples
> 
> ## (empirical) Data
> x <- rgamma(50, scale = 0.5, shape = 3)
> 
> ## parametric family of probability measures
> G <- GammaFamily(scale = 1, shape = 2)
> 
> ## Kolmogorov(-Smirnov) minimum distance estimator
> MDEstimator(x = x, ParamFamily = G, distance = KolmogorovDist)
Evaluations of Minimum Kolmogorov distance estimate:
----------------------------------------------------
An object of class “Estimate” 
generated by call
  MDEstimator(x = x, ParamFamily = G, distance = KolmogorovDist)
samplesize:   50
estimate:
    scale     shape 
0.3398645 4.2654569 
Criterion:
Kolmogorov distance 
         0.06350364 
> ## or
> KolmogorovMDEstimator(x = x, ParamFamily = G)
Evaluations of Minimum Kolmogorov distance estimate:
----------------------------------------------------
An object of class “Estimate” 
generated by call
  MDEstimator(x = x, ParamFamily = ParamFamily, distance = KolmogorovDist, 
    paramDepDist = paramDepDist, startPar = startPar, Infos = Infos, 
    trafo = trafo, penalty = penalty, validity.check = validity.check, 
    asvar.fct = asvar.fct, na.rm = na.rm, .withEvalAsVar = .withEvalAsVar)
samplesize:   50
estimate:
    scale     shape 
0.3398645 4.2654569 
Criterion:
Kolmogorov distance 
         0.06350364 
> 
> ## von Mises minimum distance estimator with default mu
> MDEstimator(x = x, ParamFamily = G, distance = CvMDist)
Evaluations of Minimum CvM distance estimate:
---------------------------------------------
An object of class “Estimate” 
generated by call
  MDEstimator(x = x, ParamFamily = G, distance = CvMDist)
samplesize:   50
estimate:
    scale     shape 
0.3401751 4.1262425 
Criterion:
CvM distance 
  0.02931495 
> 
> ## Not run: 
> ##D ## von Mises minimum distance estimator with default mu
> ##D MDEstimator(x = x, ParamFamily = G, distance = CvMDist,
> ##D             asvar.fct = .CvMMDCovariance)
> ##D ## or
> ##D CvMMDEstimator(x = x, ParamFamily = G)
> ##D 
> ##D ## von Mises minimum distance estimator with mu = N(0,1)
> ##D MDEstimator(x = x, ParamFamily = G, distance = CvMDist, mu = Norm())
> ##D 
> ##D ## Total variation minimum distance estimator
> ##D ## gamma distributions are discretized
> ##D MDEstimator(x = x, ParamFamily = G, distance = TotalVarDist)
> ##D ## or
> ##D TotalVarMDEstimator(x = x, ParamFamily = G)
> ##D ## or smoothing of emprical distribution (takes some time!)
> ##D #MDEstimator(x = x, ParamFamily = G, distance = TotalVarDist, asis.smooth.discretize = "smooth")
> ##D 
> ##D ## Hellinger minimum distance estimator
> ##D ## gamma distributions are discretized
> ##D distroptions(DistrResolution = 1e-10)
> ##D MDEstimator(x = x, ParamFamily = G, distance = HellingerDist, startPar = c(1,2))
> ##D ## or
> ##D HellingerMDEstimator(x = x, ParamFamily = G, startPar = c(1,2))
> ##D distroptions(DistrResolution = 1e-6) # default
> ##D ## or smoothing of emprical distribution (takes some time!)
> ##D MDEstimator(x = x, ParamFamily = G, distance = HellingerDist, asis.smooth.discretize = "smooth")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("MLEstimator")
> ### * MLEstimator
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MLEstimator
> ### Title: Function to compute maximum likelihood estimates
> ### Aliases: MLEstimator
> ### Keywords: univar
> 
> ### ** Examples
> 
> #############################
> ## 1. Binomial data
> #############################
> ## (empirical) data
> x <- rbinom(100, size=25, prob=.25)
> 
> ## ML-estimate
> MLEstimator(x, BinomFamily(size = 25))
Evaluations of Maximum likelihood estimate:
-------------------------------------------
An object of class “Estimate” 
generated by call
  MLEstimator(x = x, ParamFamily = BinomFamily(size = 25))
samplesize:   100
estimate:
              
  0.254000000 
 (0.008705952)
fixed part of the parameter:
size 
  25 
asymptotic (co)variance (multiplied with samplesize):
[1] 0.00757936
Criterion:
negative log-likelihood 
               207.2445 
> 
> 
> #############################
> ## 2. Poisson data
> #############################
> ## Example: Rutherford-Geiger (1910); cf. Feller~(1968), Section VI.7 (a)
> x <- c(rep(0, 57), rep(1, 203), rep(2, 383), rep(3, 525), rep(4, 532), 
+        rep(5, 408), rep(6, 273), rep(7, 139), rep(8, 45), rep(9, 27), 
+        rep(10, 10), rep(11, 4), rep(12, 0), rep(13, 1), rep(14, 1))
> 
> ## ML-estimate
> MLEstimator(x, PoisFamily())
Evaluations of Maximum likelihood estimate:
-------------------------------------------
An object of class “Estimate” 
generated by call
  MLEstimator(x = x, ParamFamily = PoisFamily())
samplesize:   2608
estimate:
             
  3.87154908 
 (0.03852908)
asymptotic (co)variance (multiplied with samplesize):
[1] 3.871549
Criterion:
negative log-likelihood 
               5352.105 
> 
> 
> #############################
> ## 3. Normal (Gaussian) location and scale
> #############################
> ## (empirical) data
> x <- rnorm(100)
> 
> ## ML-estimate
> MLEstimator(x, NormLocationScaleFamily())
Evaluations of Maximum likelihood estimate:
-------------------------------------------
An object of class “Estimate” 
generated by call
  MLEstimator(x = x, ParamFamily = NormLocationScaleFamily())
samplesize:   100
estimate:
      mean           sd     
  -0.01757949    0.93530600 
 ( 0.09353060) ( 0.06613612)
asymptotic (co)variance (multiplied with samplesize):
          mean        sd
mean 0.8747973 0.0000000
sd   0.0000000 0.4373987
Criterion:
negative log-likelihood 
               135.2057 
> ## compare:
> c(mean(x),sd(x))
[1] -0.01757949  0.94001789
> 
> 
> #############################
> ## 4. Gamma model
> #############################
> ## (empirical) data
> x <- rgamma(50, scale = 0.5, shape = 3)
> 
> ## parametric family of probability measures
> G <- GammaFamily(scale = 1, shape = 2)
> 
> ## Maximum likelihood estimator
> (res <- MLEstimator(x = x, ParamFamily = G))
Evaluations of Maximum likelihood estimate:
-------------------------------------------
An object of class “Estimate” 
generated by call
  MLEstimator(x = x, ParamFamily = G)
samplesize:   50
estimate:
     scale       shape  
  0.5360537   3.0117887 
 (0.1108070) (0.5721441)
asymptotic (co)variance (multiplied with samplesize):
           scale     shape
scale  0.6139092 -2.913162
shape -2.9131624 16.367446
Criterion:
negative log-likelihood 
               61.32426 
> 
> ## Asymptotic (CLT-based) confidence interval
> confint(res)
A[n] asymptotic (CLT-based) confidence interval:
         2.5 %    97.5 %
scale 0.318876 0.7532313
shape 1.890407 4.1331707
Type of estimator: Maximum likelihood estimate
samplesize:   50
Call by which estimate was produced:
MLEstimator(x = x, ParamFamily = G)
> 
> ## some profiling
> par(mfrow=c(1,2))
> plot(profile(res))
> par(mfrow=c(1,1))
> 
> ## implementation of ML-estimator of package MASS
> require(MASS)
> (res1 <- fitdistr(x, "gamma"))
     shape       rate   
  3.0117885   1.8655681 
 (0.5721425) (0.3856279)
> 
> ## comparison
> ## shape
> estimate(res)[2]
   shape 
3.011789 
> ## rate
> 1/estimate(res)[1]
   scale 
1.865485 
> 
> ## minor differences due to the fact that by default, fitdistr uses
> ## BFGS, while we use Nelder-Mead instead
> 
> ## log-likelihood
> res1$loglik
[1] -61.32426
> ## negative log-likelihood
> criterion(res)
negative log-likelihood 
               61.32426 
> 
> 
> ## explicitely transforming to
> ## MASS parametrization:
> mtrafo <- function(x){
+      nms0 <- names(c(main(param(G)),nuisance(param(G))))
+      nms <- c("shape","rate")
+      fval0 <- c(x[2], 1/x[1])
+      names(fval0) <- nms
+      mat0 <- matrix( c(0, -1/x[1]^2, 1, 0), nrow = 2, ncol = 2,
+                      dimnames = list(nms,nms0))                          
+      list(fval = fval0, mat = mat0)}
> 
> G2 <- G
> trafo(G2) <- mtrafo
> res2 <- MLEstimator(x = x, ParamFamily = G2)
> 
> old <- getdistrModOption("show.details")
> distrModoptions("show.details" = "minimal")
> res1
     shape       rate   
  3.0117885   1.8655681 
 (0.5721425) (0.3856279)
> res2
Evaluations of Maximum likelihood estimate:
-------------------------------------------
     shape       rate   
  3.0117887   1.8654848 
 (0.5721441) (0.3856120)
> 
> ## some profiling
> par(mfrow=c(1,2))
> plot(profile(res2))
> par(mfrow=c(1,1))
> 
> #############################
> ## 5. Cauchy Location Scale model
> #############################
> (C <- CauchyLocationScaleFamily())
An object of class "CauchyLocationScaleFamily"
### name:	Cauchy Location and scale family

### distribution:	Distribution Object of Class: Cauchy
 location: 0
 scale: 1

### param:	An object of class "ParamWithScaleFamParameter"
name:	location and scale
loc:	0
scale:	1

### props:
[1] "The Cauchy Location and scale family is invariant under"  
[2] "the group of transformations 'g(x) = scale*x + loc'"      
[3] "with location parameter 'loc' and scale parameter 'scale'"
> loc.true <- 1
> scl.true <- 2
> 
> ## (empirical) data
> x <- rcauchy(50, location = loc.true, scale = scl.true)
> 
> ## Maximum likelihood estimator
> (res <- MLEstimator(x = x, ParamFamily = C))
Evaluations of Maximum likelihood estimate:
-------------------------------------------
      loc        scale  
  1.2124856   1.6358162 
 (0.3271632) (0.3271632)
> ## Asymptotic (CLT-based) confidence interval
> confint(res)
A[n] asymptotic (CLT-based) confidence interval:
          2.5 %   97.5 %
loc   0.5712574 1.853714
scale 0.9945880 2.277044
> 
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("NBinomFamily")
> ### * NBinomFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NbinomFamily
> ### Title: Generating function for Nbinomial families
> ### Aliases: NbinomFamily NbinomwithSizeFamily NbinomMeanSizeFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (N1 <- NbinomFamily(size = 25, prob = 0.25))
An object of class "NbinomFamily"
### name:	Negative Binomial family

### distribution:	Distribution Object of Class: Nbinom
 size: 25
 prob: 0.25

### param:	An object of class "ParamFamParameter"
name:	probability of success
prob:	0.25
fixed part of param.:
	size:	25

### props:
[1] ""
> plot(N1)
> FisherInfo(N1)
An object of class "PosSemDefSymmMatrix"
         prob
prob 533.3333
> checkL2deriv(N1)
precision of centering:	 0.001177892 
precision of Fisher information:
           prob
prob -0.1601189
precision of Fisher information - relativ error [%]:
           prob
prob -0.0300223
condition of Fisher information:
[1] 1
$maximum.deviation
[1] 0.1601189

> (N1.w <- NbinomwithSizeFamily(size = 25, prob = 0.25))
An object of class "NbinomwithSizeFamily"
### name:	Negative Binomial family

### distribution:	Distribution Object of Class: Nbinom
 size: 25
 prob: 0.25

### param:	An object of class "ParamFamParameter"
name:	NegBinomParameter
size:	25
prob:	0.25

### props:
[1] ""
> plot(N1.w)
> FisherInfo(N1.w)
An object of class "PosSemDefSymmMatrix"
            size     prob
size  0.03044946  -4.0000
prob -4.00000000 533.3333
> checkL2deriv(N1.w)
precision of centering:	 -6.245978e-06 0.001177892 
precision of Fisher information:
              size          prob
size -4.182531e-06  0.0008481424
prob  8.481424e-04 -0.1601189384
precision of Fisher information - relativ error [%]:
            size        prob
size -0.01373598 -0.02120356
prob -0.02120356 -0.03002230
condition of Fisher information:
[1] 1195572
$maximum.deviation
[1] 0.1601189

> (N2.w <- NbinomMeanSizeFamily(size = 25, mean = 75))
An object of class "NbinomMeanSizeFamily"
### name:	Negative Binomial family

### distribution:	Distribution Object of Class: Nbinom
 size: 25
 prob: 0.25

### param:	An object of class "ParamFamParameter"
name:	probability of success
size:	25
mean:	75

### props:
[1] ""
> plot(N2.w)
> FisherInfo(N2.w)
An object of class "PosSemDefSymmMatrix"
             size         mean
size 3.044946e-02     1600.091
mean 1.600091e+03 85342933.607
> checkL2deriv(N2.w)
precision of centering:	 -6.245978e-06 -0.4711755 
precision of Fisher information:
              size          mean
size -4.182531e-06 -3.392695e-01
mean -3.392695e-01 -2.562107e+04
precision of Fisher information - relativ error [%]:
            size        mean
size -0.01373598 -0.02120313
mean -0.02120313 -0.03002131
condition of Fisher information:
[1] 1.89903e+11
$maximum.deviation
[1] 25621.07

> 
> 
> 
> 
> cleanEx()
> nameEx("NonSymmetric-class")
> ### * NonSymmetric-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NonSymmetric-class
> ### Title: Class for Non-symmetric Functions
> ### Aliases: NonSymmetric-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("NonSymmetric")
type of symmetry:	non-symmetric function
NULL
> 
> 
> 
> cleanEx()
> nameEx("NonSymmetric")
> ### * NonSymmetric
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NonSymmetric
> ### Title: Generating function for NonSymmetric-class
> ### Aliases: NonSymmetric
> ### Keywords: math
> 
> ### ** Examples
> 
> NonSymmetric()
type of symmetry:	non-symmetric function
NULL
> 
> ## The function is currently defined as
> function(){ new("NonSymmetric") }
function () 
{
    new("NonSymmetric")
}
> 
> 
> 
> cleanEx()
> nameEx("NormLocationFamily")
> ### * NormLocationFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NormLocationFamily
> ### Title: Generating function for normal location families
> ### Aliases: NormLocationFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (N1 <- NormLocationFamily())
An object of class "NormLocationFamily"
### name:	normal location family

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1
Warning in show(x) :
  arithmetics on distributions are understood as operations on r.v.'s
see 'distrARITH()'; for switching off this warning see '?distroptions'

### param:	An object of class "ParamFamParameter"
name:	loc
mean:	0

### props:
[1] "The normal location family is invariant under"
[2] "the group of transformations 'g(x) = x + loc'"
[3] "with location parameter 'loc'"                
> plot(N1)
> L2derivDistr(N1)
An object of class "UnivarDistrList"
 [[1]] Distribution Object of Class: Norm
       :mean: 0
       :sd: 1
> 
> 
> 
> cleanEx()
> nameEx("NormLocationScaleFamily")
> ### * NormLocationScaleFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NormLocationScaleFamily
> ### Title: Generating function for normal location and scale families
> ### Aliases: NormLocationScaleFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (N1 <- NormLocationScaleFamily())
An object of class "NormLocationScaleFamily"
### name:	normal location and scale family

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1
Warning in show(x) :
  arithmetics on distributions are understood as operations on r.v.'s
see 'distrARITH()'; for switching off this warning see '?distroptions'

### param:	An object of class "ParamWithScaleFamParameter"
name:	location and scale
mean:	0
sd:	1

### props:
[1] "The normal location and scale family is invariant under"  
[2] "the group of transformations 'g(x) = scale*x + loc'"      
[3] "with location parameter 'loc' and scale parameter 'scale'"
> plot(N1)
> FisherInfo(N1)
An object of class "PosDefSymmMatrix"
     mean sd
mean    1  0
sd      0  2
> checkL2deriv(N1)
precision of centering:	 0 -5.594001e-06 
precision of Fisher information:
              mean            sd
mean -5.794001e-06  0.0000000000
sd    0.000000e+00 -0.0001572173
precision of Fisher information - relativ error [%]:
              mean           sd
mean -0.0005794001          NaN
sd             NaN -0.007860863
condition of Fisher information:
[1] 1.666667
$maximum.deviation
[1] 0.0001572173

> 
> 
> 
> cleanEx()
> nameEx("NormLocationUnknownScaleFamily")
> ### * NormLocationUnknownScaleFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NormLocationUnknownScaleFamily
> ### Title: Generating function for normal location families with unknown
> ###   scale as nuisance
> ### Aliases: NormLocationUnknownScaleFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (N1 <- NormLocationUnknownScaleFamily())
An object of class "L2LocationScaleFamily"
### name:	normal location family with unknown scale (as nuisance)

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1
Warning in show(x) :
  arithmetics on distributions are understood as operations on r.v.'s
see 'distrARITH()'; for switching off this warning see '?distroptions'

### param:	An object of class "ParamWithScaleFamParameter"
name:	location and scale
mean:	0
nuisance:
sd:	1

### props:
[1] "The normal location family with unknown scale (as nuisance) is invariant under"
[2] "the group of transformations 'g(x) = scale*x + loc'"                           
[3] "with location parameter 'loc' and scale parameter 'scale'"                     
> plot(N1)
> FisherInfo(N1)
An object of class "PosDefSymmMatrix"
     mean sd
mean    1  0
sd      0  2
> checkL2deriv(N1)
precision of centering:	 0 -5.594001e-06 
precision of Fisher information:
              mean            sd
mean -5.794001e-06  0.0000000000
sd    0.000000e+00 -0.0001572173
precision of Fisher information - relativ error [%]:
              mean           sd
mean -0.0005794001          NaN
sd             NaN -0.007860863
condition of Fisher information:
[1] 1.666667
$maximum.deviation
[1] 0.0001572173

> 
> 
> 
> cleanEx()
> nameEx("NormScaleFamily")
> ### * NormScaleFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NormScaleFamily
> ### Title: Generating function for normal scale families
> ### Aliases: NormScaleFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (N1 <- NormScaleFamily())
An object of class "NormScaleFamily"
### name:	normal scale family

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1
Warning in show(x) :
  arithmetics on distributions are understood as operations on r.v.'s
see 'distrARITH()'; for switching off this warning see '?distroptions'

### param:	An object of class "ParamWithScaleFamParameter"
name:	scale
sd:	1
fixed part of param.:
	mean:	0

### props:
[1] "The normal scale family is invariant under"   
[2] "the group of transformations 'g(y) = scale*y'"
[3] "with scale parameter 'scale'"                 
> plot(N1)
> FisherInfo(N1)
An object of class "PosDefSymmMatrix"
   sd
sd  2
> checkL2deriv(N1)
precision of centering:	 -5.594001e-06 
precision of Fisher information:
              sd
sd -0.0001572173
precision of Fisher information - relativ error [%]:
             sd
sd -0.007860863
condition of Fisher information:
[1] 1
$maximum.deviation
[1] 0.0001572173

> 
> 
> 
> cleanEx()
> nameEx("NormScaleUnknownLocationFamily")
> ### * NormScaleUnknownLocationFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NormScaleUnknownLocationFamily
> ### Title: Generating function for normal scale families with unknown
> ###   location as nuisance
> ### Aliases: NormScaleUnknownLocationFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (N1 <- NormScaleUnknownLocationFamily())
An object of class "L2LocationScaleFamily"
### name:	normal scale family with unknown location (as nuisance)

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1
Warning in show(x) :
  arithmetics on distributions are understood as operations on r.v.'s
see 'distrARITH()'; for switching off this warning see '?distroptions'

### param:	An object of class "ParamWithScaleFamParameter"
name:	scale and location
sd:	1
nuisance:
mean:	0

### props:
[1] "The normal scale family with unknown location (as nuisance) is invariant under"
[2] "the group of transformations 'g(x) = scale*x + loc'"                           
[3] "with location parameter 'loc' and scale parameter 'scale'"                     
> plot(N1)
> FisherInfo(N1)
An object of class "PosDefSymmMatrix"
     sd mean
sd    1    0
mean  0    2
> checkL2deriv(N1)
precision of centering:	 0 -5.594001e-06 
precision of Fisher information:
                sd          mean
sd   -5.794001e-06  0.0000000000
mean  0.000000e+00 -0.0001572173
precision of Fisher information - relativ error [%]:
                sd         mean
sd   -0.0005794001          NaN
mean           NaN -0.007860863
condition of Fisher information:
[1] 1.666667
$maximum.deviation
[1] 0.0001572173

> 
> 
> 
> cleanEx()
> nameEx("NormType-class")
> ### * NormType-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NormType-class
> ### Title: Norm Type
> ### Aliases: NormType-class name,NormType-method name<-,NormType-method fct
> ###   fct<- fct,NormType-method fct<-,NormType-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> EuclNorm <- NormType("EuclideanNorm",EuclideanNorm)
> fct(EuclNorm)
function (x) 
{
    if (is.vector(x)) 
        return(abs(x))
    else return(sqrt(colSums(x^2)))
}
<bytecode: 0x12991d28>
<environment: namespace:distrMod>
> name(EuclNorm)
[1] "EuclideanNorm"
> 
> 
> 
> cleanEx()
> nameEx("NormType")
> ### * NormType
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NormType
> ### Title: Generating function for NormType-class
> ### Aliases: NormType
> ### Keywords: math
> 
> ### ** Examples
> 
> NormType()
An object of class "NormType"
Slot "name":
[1] "EuclideanNorm"

Slot "fct":
function (x) 
{
    if (is.vector(x)) 
        return(abs(x))
    else return(sqrt(colSums(x^2)))
}
<bytecode: 0x12991d28>
<environment: namespace:distrMod>

> 
> 
> 
> cleanEx()
> nameEx("OddSymmetric-class")
> ### * OddSymmetric-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: OddSymmetric-class
> ### Title: Class for Odd Functions
> ### Aliases: OddSymmetric-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("OddSymmetric")
type of symmetry:	odd function
center of symmetry:
numeric(0)
> 
> 
> 
> cleanEx()
> nameEx("OddSymmetric")
> ### * OddSymmetric
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: OddSymmetric
> ### Title: Generating function for OddSymmetric-class
> ### Aliases: OddSymmetric
> ### Keywords: math
> 
> ### ** Examples
> 
> OddSymmetric()
type of symmetry:	odd function
center of symmetry:
[1] 0
> 
> ## The function is currently defined as
> function(SymmCenter = 0){ 
+     new("OddSymmetric", SymmCenter = SymmCenter) 
+ }
function (SymmCenter = 0) 
{
    new("OddSymmetric", SymmCenter = SymmCenter)
}
> 
> 
> 
> cleanEx()
> nameEx("ParamFamParameter-class")
> ### * ParamFamParameter-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ParamFamParameter-class
> ### Title: Parameter of a parametric family of probability measures
> ### Aliases: ParamFamParameter-class ParamWithScaleFamParameter-class
> ###   ParamWithScaleAndShapeFamParameter-class
> ###   ParamWithShapeFamParameter-class length,ParamFamParameter-method
> ###   dimension,ParamFamParameter-method main main,ParamFamParameter-method
> ###   main,ParamWithScaleAndShapeFamParameter-method main<-
> ###   main<-,ParamFamParameter-method nuisance
> ###   nuisance,ParamFamParameter-method
> ###   nuisance,ParamWithScaleAndShapeFamParameter-method nuisance<-
> ###   nuisance<-,ParamFamParameter-method fixed
> ###   fixed,ParamFamParameter-method
> ###   fixed,ParamWithScaleAndShapeFamParameter-method fixed<-
> ###   fixed<-,ParamFamParameter-method withPosRestr
> ###   withPosRestr,ParamWithShapeFamParameter-method withPosRestr<-
> ###   withPosRestr<-,ParamWithShapeFamParameter-method
> ###   show,ParamFamParameter-method show,ParamWithShapeFamParameter-method
> ###   show,ParamWithScaleAndShapeFamParameter-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("ParamFamParameter")
An object of class "ParamFamParameter"
name:	parameter of a parametric family of probability measures
> 
> 
> 
> cleanEx()
> nameEx("ParamFamParameter")
> ### * ParamFamParameter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ParamFamParameter
> ### Title: Generating function for ParamFamParameter-class
> ### Aliases: ParamFamParameter
> ### Keywords: models
> 
> ### ** Examples
> 
> ParamFamParameter(main = 0, nuisance = 1, fixed = 2,
+                   trafo = function(x) list(fval = sin(x), 
+                                             mat = matrix(cos(x),1,1))
+                   )                          
An object of class "ParamFamParameter"
name:	parameter of a parametric family of probability measures
main:	0
nuisance:	1
fixed part of param.:	2
> 
> 
> 
> 
> cleanEx()
> nameEx("ParamFamily-class")
> ### * ParamFamily-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ParamFamily-class
> ### Title: Parametric family of probability measures.
> ### Aliases: ParamFamily-class main,ParamFamily-method
> ###   nuisance,ParamFamily-method fixed,ParamFamily-method
> ###   param,ParamFamily-method modifyParam modifyParam,ParamFamily-method
> ###   fam.call fam.call,ParamFamily-method startPar
> ###   startPar,ParamFamily-method makeOKPar makeOKPar,ParamFamily-method
> ###   plot,ParamFamily,missing-method show,ParamFamily-method
> ### Keywords: classes models
> 
> ### ** Examples
> 
> F1 <- new("ParamFamily") # prototype
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("ParamFamily")
> ### * ParamFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ParamFamily
> ### Title: Generating function for ParamFamily-class
> ### Aliases: ParamFamily
> ### Keywords: distribution models
> 
> ### ** Examples
> 
> 
> ## "default" (normal location)
> F1 <- ParamFamily(modifyParam = function(theta){ Norm(mean = theta) })
> plot(F1)
> 
> ################################
> ## Some examples:
> ################################
> ## 1. Normal location family
> theta <- 0
> names(theta) <- "mean"
> NL <- ParamFamily(name = "Normal location family",
+           param = ParamFamParameter(name = "location parameter", main = theta),
+           distribution = Norm(mean = 0, sd = 1), ## sd known!
+           startPar = function(x,...) c(min(x),max(x)),
+           distrSymm <- SphericalSymmetry(SymmCenter = 0),
+           modifyParam = function(theta){ Norm(mean = theta, sd = 1) },
+           props = paste(c("The normal location family is invariant under",
+                     "the group of transformations 'g(x) = x + mean'",
+                     "with location parameter 'mean'"), collapse = " "))
> NL
An object of class "ParamFamily"
### name:	Normal location family

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1

### param:	An object of class "ParamFamParameter"
name:	location parameter
mean:	0

### props:
[1] "The normal location family is invariant under the group of transformations 'g(x) = x + mean' with location parameter 'mean'"
> 
> ## 2. Normal scale family
> theta <- 1
> names(theta) <- "sd"
> NS <- ParamFamily(name = "Normal scale family",
+           param = ParamFamParameter(name = "scale parameter", main = theta,
+           .returnClsName = "ParamWithScaleFamParameter"),
+           distribution = Norm(mean = 0, sd = 1), ## mean known!
+           startPar = function(x,...) c(0,-min(x)+max(x)),
+           distrSymm <- SphericalSymmetry(SymmCenter = 0),
+           modifyParam = function(theta){ Norm(mean = 0, sd = theta) },
+           props = paste(c("The normal scale family is invariant under",
+                     "the group of transformations 'g(y) = sd*y'",
+                     "with scale parameter 'sd'"), collapse = " "))
> NS
An object of class "ParamFamily"
### name:	Normal scale family

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1

### param:	An object of class "ParamWithScaleFamParameter"
name:	scale parameter
sd:	1

### props:
[1] "The normal scale family is invariant under the group of transformations 'g(y) = sd*y' with scale parameter 'sd'"
> 
> ## 3. Normal location and scale family
> theta <- c(0, 1)
> names(theta) <- c("mean", "sd")
> NLS <- ParamFamily(name = "Normal location and scale family",
+           param = ParamFamParameter(name = "location and scale parameter",
+                                     main = theta,
+                                  .returnClsName = "ParamWithScaleFamParameter"),
+           distribution = Norm(mean = 0, sd = 1),
+           startPar = function(x,...) c(median(x),mad(x)),
+           makeOKPar = function(param) {param[2]<-abs(param[2]); return(param)},
+           distrSymm <- SphericalSymmetry(SymmCenter = 0),
+           modifyParam = function(theta){
+                             Norm(mean = theta[1], sd = theta[2])
+                         },
+           props = paste(c("The normal location and scale family is",
+                     "invariant under the group of transformations",
+                     "'g(x) = sd*x + mean' with location parameter",
+                     "'mean' and scale parameter 'sd'"),
+                     collapse = " "))
> NLS
An object of class "ParamFamily"
### name:	Normal location and scale family

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1

### param:	An object of class "ParamWithScaleFamParameter"
name:	location and scale parameter
mean:	0
sd:	1

### props:
[1] "The normal location and scale family is invariant under the group of transformations 'g(x) = sd*x + mean' with location parameter 'mean' and scale parameter 'sd'"
> 
> ## 4. Binomial family
> theta <- 0.3
> names(theta) <- "prob"
> B <- ParamFamily(name = "Binomial family",
+          param = ParamFamParameter(name = "probability of success", 
+                                    main = theta),
+          startPar = function(x,...) c(0,1),
+          distribution = Binom(size = 15, prob = 0.3), ## size known!
+          modifyParam = function(theta){ Binom(size = 15, prob = theta) },
+          props = paste(c("The Binomial family is symmetric with respect",
+                    "to prob = 0.5; i.e.,",
+                    "d(Binom(size, prob))(k)=d(Binom(size,1-prob))(size-k)"),
+                    collapse = " "))
> B
An object of class "ParamFamily"
### name:	Binomial family

### distribution:	Distribution Object of Class: Binom
 size: 15
 prob: 0.3

### param:	An object of class "ParamFamParameter"
name:	probability of success
prob:	0.3

### props:
[1] "The Binomial family is symmetric with respect to prob = 0.5; i.e., d(Binom(size, prob))(k)=d(Binom(size,1-prob))(size-k)"
> 
> ## 5. Poisson family
> theta <- 7
> names(theta) <- "lambda"
> P <- ParamFamily(name = "Poisson family",
+           param = ParamFamParameter(name = "positive mean", main = theta),
+           startPar = function(x,...) c(0,max(x)),
+           distribution = Pois(lambda = 7),
+           modifyParam = function(theta){ Pois(lambda = theta) })
> P
An object of class "ParamFamily"
### name:	Poisson family

### distribution:	Distribution Object of Class: Pois
 lambda: 7

### param:	An object of class "ParamFamParameter"
name:	positive mean
lambda:	7
> 
> 
> ## 6. Exponential scale family
> theta <- 2
> names(theta) <- "scale"
> ES <- ParamFamily(name = "Exponential scale family",
+           param = ParamFamParameter(name = "scale parameter", main = theta,
+                            .returnClsName = "ParamWithScaleFamParameter"),
+           startPar = function(x,...) c(0,max(x)-min(x)),
+           distribution = Exp(rate = 1/2),
+           modifyParam = function(theta){ Exp(rate = 1/theta) },
+           props = paste(c("The Exponential scale family is invariant under",
+                     "the group of transformations 'g(y) = scale*y'",
+                     "with scale parameter 'scale = 1/rate'"),
+                     collapse = " " ))
> ES
An object of class "ParamFamily"
### name:	Exponential scale family

### distribution:	Distribution Object of Class: Exp
 rate: 0.5

### param:	An object of class "ParamWithScaleFamParameter"
name:	scale parameter
scale:	2

### props:
[1] "The Exponential scale family is invariant under the group of transformations 'g(y) = scale*y' with scale parameter 'scale = 1/rate'"
> 
> ## 7. Lognormal scale family
> theta <- 2
> names(theta) <- "scale"
> LS <- ParamFamily(name = "Lognormal scale family",
+           param = ParamFamParameter(name = "scale parameter", main = theta,
+                            .returnClsName = "ParamWithScaleFamParameter"),
+           startPar = function(x,...) c(0,max(x)-min(x)),
+           distribution = Lnorm(meanlog = log(2), sdlog = 2),## sdlog known!
+           modifyParam = function(theta){ 
+                             Lnorm(meanlog = log(theta), sdlog = 2) 
+                         },
+           props = paste(c("The Lognormal scale family is invariant under",
+                     "the group of transformations 'g(y) = scale*y'",
+                     "with scale parameter 'scale = exp(meanlog)'"),
+                     collapse = " "))
> LS
An object of class "ParamFamily"
### name:	Lognormal scale family

### distribution:	Distribution Object of Class: Lnorm
 meanlog: 0.693147180559945
 sdlog: 2

### param:	An object of class "ParamWithScaleFamParameter"
name:	scale parameter
scale:	2

### props:
[1] "The Lognormal scale family is invariant under the group of transformations 'g(y) = scale*y' with scale parameter 'scale = exp(meanlog)'"
> 
> ## 8. Gamma family
> theta <- c(1, 2)
> names(theta) <- c("scale", "shape")
> G <- ParamFamily(name = "Gamma family",
+         param = ParamFamParameter(name = "scale and shape", main = theta,
+                            withPosRestr = TRUE,
+                            .returnClsName = "ParamWithScaleAndShapeFamParameter"),
+         startPar = function(x,...) {E <- mean(x); V <- var(X); c(V/E,E^2/V)},
+         makeOKPar = function(param) abs(param),
+         distribution = Gammad(scale = 1, shape = 2),
+         modifyParam = function(theta){ 
+                           Gammad(scale = theta[1], shape = theta[2]) 
+                       },
+         props = paste(c("The Gamma family is scale invariant via the",
+                   "parametrization '(nu,shape)=(log(scale),shape)'"),
+                   collapse = " "))
> G
An object of class "ParamFamily"
### name:	Gamma family

### distribution:	Distribution Object of Class: Gammad
 shape: 2
 scale: 1

### param:	An object of class "ParamFamParameter"
name:	scale and shape
scale:	1
shape:	2
Shape parameter must not be negative.

### props:
[1] "The Gamma family is scale invariant via the parametrization '(nu,shape)=(log(scale),shape)'"
> 
> 
> 
> cleanEx()
> nameEx("PoisFamily")
> ### * PoisFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PoisFamily
> ### Title: Generating function for Poisson families
> ### Aliases: PoisFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (P1 <- PoisFamily(lambda = 4.5))
An object of class "PoisFamily"
### name:	Poisson family

### distribution:	Distribution Object of Class: Pois
 lambda: 4.5

### param:	An object of class "ParamFamParameter"
name:	positive mean
lambda:	4.5
> plot(P1)
> FisherInfo(P1)
An object of class "PosSemDefSymmMatrix"
          lambda
lambda 0.2222222
> checkL2deriv(P1)
precision of centering:	 -9.934798e-07 
precision of Fisher information:
              lambda
lambda -3.268427e-06
precision of Fisher information - relativ error [%]:
             lambda
lambda -0.001470792
condition of Fisher information:
[1] 1
$maximum.deviation
[1] 3.268427e-06

> 
> 
> 
> cleanEx()
> nameEx("QFNorm")
> ### * QFNorm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: QFNorm
> ### Title: Generating function for QFNorm-class
> ### Aliases: QFNorm
> ### Keywords: math
> 
> ### ** Examples
> 
> QFNorm()
An object of class "QFNorm"
Slot "QuadForm":
An object of class "PosSemDefSymmMatrix"
     [,1]
[1,]    1

Slot "name":
[1] "norm based on quadratic form"

Slot "fct":
function (x) 
QuadFormNorm(x, A = A0)
<bytecode: 0xbf7c598>
<environment: 0xbf7c988>

> 
> ## The function is currently defined as
> function(){ new("QFNorm") }
function () 
{
    new("QFNorm")
}
> 
> 
> 
> cleanEx()
> nameEx("SelfNorm")
> ### * SelfNorm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SelfNorm
> ### Title: Generating function for SelfNorm-class
> ### Aliases: SelfNorm
> ### Keywords: robust
> 
> ### ** Examples
> 
> SelfNorm()
An object of class "SelfNorm"
Slot "QuadForm":
An object of class "PosSemDefSymmMatrix"
     [,1]
[1,]    1

Slot "name":
[1] "Information matrix Norm"

Slot "fct":
function (x) 
QuadFormNorm(x, A = A)
<bytecode: 0xbe53df0>
<environment: 0xbe50340>

> 
> ## The function is currently defined as
> function(){ new("SelfNorm") }
function () 
{
    new("SelfNorm")
}
> 
> 
> 
> cleanEx()
> nameEx("addAlphTrsp2col")
> ### * addAlphTrsp2col
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: addAlphTrsp2col
> ### Title: "addAlphTrsp2col"
> ### Aliases: addAlphTrsp2col
> ### Keywords: distribution
> 
> ### ** Examples
> 
>   addAlphTrsp2col(rgb(1,0.3,0.03), 25)
[1] "#FF4D0819"
>   addAlphTrsp2col("darkblue", 25)
[1] "#00008B19"
>   addAlphTrsp2col("#AAAAAAAA",25)
[1] "#AAAAAA19"
>   palette(rainbow(6))
>   addAlphTrsp2col(2, 25)
[1] "#FFFF0019"
> 
> 
> 
> cleanEx()
> nameEx("asBias-class")
> ### * asBias-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asBias-class
> ### Title: Standardized Asymptotic Bias
> ### Aliases: asBias-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("asBias")
An object of class “asBias” 
risk type:	 asymptotic bias 
> 
> 
> 
> cleanEx()
> nameEx("asBias")
> ### * asBias
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asBias
> ### Title: Generating function for asBias-class
> ### Aliases: asBias
> ### Keywords: robust
> 
> ### ** Examples
> 
> asBias()
An object of class “asBias” 
risk type:	 asymptotic bias 
> 
> ## The function is currently defined as
> function(biastype = symmetricBias(), normtype = NormType()){ 
+      new("asBias",biastype = biastype, normtype = normtype) }
function (biastype = symmetricBias(), normtype = NormType()) 
{
    new("asBias", biastype = biastype, normtype = normtype)
}
> 
> 
> 
> cleanEx()
> nameEx("asCov-class")
> ### * asCov-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asCov-class
> ### Title: Asymptotic covariance
> ### Aliases: asCov-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("asCov")
An object of class “asCov” 
risk type:	 asymptotic covariance 
> 
> 
> 
> cleanEx()
> nameEx("asCov")
> ### * asCov
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asCov
> ### Title: Generating function for asCov-class
> ### Aliases: asCov
> ### Keywords: robust
> 
> ### ** Examples
> 
> asCov()
An object of class “asCov” 
risk type:	 asymptotic covariance 
> 
> ## The function is currently defined as
> function(){ new("asCov") }
function () 
{
    new("asCov")
}
> 
> 
> 
> cleanEx()
> nameEx("asHampel-class")
> ### * asHampel-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asHampel-class
> ### Title: Asymptotic Hampel risk
> ### Aliases: asHampel-class bound bound,asHampel-method
> ###   show,asHampel-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("asHampel")
An object of class “asHampel” 
risk type:	 trace of asymptotic covariance for given bias bound 
bound:	 Inf 
> 
> 
> 
> cleanEx()
> nameEx("asHampel")
> ### * asHampel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asHampel
> ### Title: Generating function for asHampel-class
> ### Aliases: asHampel
> ### Keywords: robust
> 
> ### ** Examples
> 
> asHampel()
An object of class “asHampel” 
risk type:	 trace of asymptotic covariance for given bias bound 
bound:	 Inf 
> 
> ## The function is currently defined as
> function(bound = Inf, biastype = symmetricBias(), normtype = NormType()){ 
+     new("asHampel", bound = bound, biastype = biastype, normtype = normtype) }
function (bound = Inf, biastype = symmetricBias(), normtype = NormType()) 
{
    new("asHampel", bound = bound, biastype = biastype, normtype = normtype)
}
> 
> 
> 
> cleanEx()
> nameEx("asMSE-class")
> ### * asMSE-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asMSE-class
> ### Title: Asymptotic mean square error
> ### Aliases: asMSE-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("asMSE")
An object of class “asMSE” 
risk type:	 asymptotic mean square error 
> 
> 
> 
> cleanEx()
> nameEx("asMSE")
> ### * asMSE
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asMSE
> ### Title: Generating function for asMSE-class
> ### Aliases: asMSE
> ### Keywords: robust
> 
> ### ** Examples
> 
> asMSE()
An object of class “asMSE” 
risk type:	 asymptotic mean square error 
> 
> ## The function is currently defined as
> function(biastype = symmetricBias(), normtype = NormType()){ 
+          new("asMSE", biastype = biastype, normtype = normtype) }
function (biastype = symmetricBias(), normtype = NormType()) 
{
    new("asMSE", biastype = biastype, normtype = normtype)
}
> 
> 
> 
> cleanEx()
> nameEx("asSemivar-class")
> ### * asSemivar-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asSemivar-class
> ### Title: Semivariance Risk Type
> ### Aliases: asSemivar-class sign,asSemivar-method sign<-,asSemivar-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> asSemivar()
An object of class “asSemivar” 
risk type:	 asymptotic Semivariance 
> 
> 
> 
> cleanEx()
> nameEx("asSemivar")
> ### * asSemivar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asSemivar
> ### Title: Generating function for asSemivar-class
> ### Aliases: asSemivar
> ### Keywords: robust
> 
> ### ** Examples
> 
> asSemivar()
An object of class “asSemivar” 
risk type:	 asymptotic Semivariance 
> 
> 
> 
> 
> cleanEx()
> nameEx("asUnOvShoot-class")
> ### * asUnOvShoot-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asUnOvShoot-class
> ### Title: Asymptotic under-/overshoot probability
> ### Aliases: asUnOvShoot-class width width,asUnOvShoot-method
> ###   show,asUnOvShoot-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("asUnOvShoot")
An object of class “asUnOvShoot” 
risk type:	 asymptotic under-/overshoot probability 
width:	  
> 
> 
> 
> cleanEx()
> nameEx("asUnOvShoot")
> ### * asUnOvShoot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asUnOvShoot
> ### Title: Generating function for asUnOvShoot-class
> ### Aliases: asUnOvShoot
> ### Keywords: robust
> 
> ### ** Examples
> 
> asUnOvShoot()
An object of class “asUnOvShoot” 
risk type:	 asymptotic under-/overshoot probability 
width:	 1.96 
> 
> ## The function is currently defined as
> function(width = 1.960, biastype = symmetricBias()){ 
+      new("asUnOvShoot", width = width, biastype = biastype) }
function (width = 1.96, biastype = symmetricBias()) 
{
    new("asUnOvShoot", width = width, biastype = biastype)
}
> 
> 
> 
> cleanEx()
> nameEx("asymmetricBias-class")
> ### * asymmetricBias-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asymmetricBias-class
> ### Title: asymmetric Bias Type
> ### Aliases: asymmetricBias-class nu,asymmetricBias-method
> ###   nu<-,asymmetricBias-method nu nu<-
> ### Keywords: classes
> 
> ### ** Examples
> 
> asymmetricBias()
An object of class "asymmetricBias"
Slot "nu":
[1] 1 1

Slot "name":
[1] "asymmetric Bias"

> ## The function is currently defined as
> function(){ new("asymmetricBias", name = "asymmetric Bias", nu = c(1,1)) }
function () 
{
    new("asymmetricBias", name = "asymmetric Bias", nu = c(1, 
        1))
}
> 
> aB <- asymmetricBias()
> nu(aB)
[1] 1 1
> try(nu(aB) <- -2) ## error
Error in `nu<-`(`*tmp*`, value = -2) : 
  Left value has to be in (0,1]x(0,1] with maximum 1
> nu(aB) <- c(0.3,1)
> 
> 
> 
> cleanEx()
> nameEx("asymmetricBias")
> ### * asymmetricBias
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asymmetricBias
> ### Title: Generating function for asymmetricBias-class
> ### Aliases: asymmetricBias
> ### Keywords: robust
> 
> ### ** Examples
> 
> asymmetricBias()
An object of class "asymmetricBias"
Slot "nu":
[1] 1 1

Slot "name":
[1] "asymmetric Bias"

> 
> ## The function is currently defined as
> function(){ new("asymmetricBias", name = "asymmetric Bias", nu = c(1,1)) }
function () 
{
    new("asymmetricBias", name = "asymmetric Bias", nu = c(1, 
        1))
}
> 
> 
> 
> cleanEx()
> nameEx("checkL2deriv")
> ### * checkL2deriv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkL2deriv
> ### Title: Generic function for checking L2-derivatives
> ### Aliases: checkL2deriv
> ### Keywords: models
> 
> ### ** Examples
> 
> F1 <- new("L2ParamFamily")
> checkL2deriv(F1)
precision of centering:	 0 
precision of Fisher information:
              [,1]
[1,] -5.794001e-06
precision of Fisher information - relativ error [%]:
              [,1]
[1,] -0.0005794001
condition of Fisher information:
[1] 1
$maximum.deviation
[1] 5.794001e-06

> 
> 
> 
> cleanEx()
> nameEx("confint-methods")
> ### * confint-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: confint-methods
> ### Title: Methods for function confint in Package 'distrMod'
> ### Aliases: confint-methods confint confint,ANY,missing-method
> ###   confint,Estimate,missing-method confint,mle,missing-method
> ###   confint,profile.mle,missing-method
> ### Keywords: models
> 
> ### ** Examples
> 
> ## for signature ANY examples confer stats::confint
> ## (empirical) Data
> x <- rgamma(50, scale = 0.5, shape = 3)
> 
> ## parametric family of probability measures
> G <- GammaFamily(scale = 1, shape = 2)
> 
> ## Maximum likelihood estimator
> res <- MLEstimator(x = x, ParamFamily = G)
> confint(res)
A[n] asymptotic (CLT-based) confidence interval:
          2.5 %    97.5 %
scale 0.2047574 0.4792587
shape 2.5295729 5.5909984
> 
> ### for comparison:
> require(MASS)
> (res1 <- fitdistr(x, "gamma"))
Warning in densfun(x, parm[1], parm[2], ...) : NaNs produced
     shape       rate   
  4.0606867   2.9242396 
 (0.7810673) (0.5987423)
> ## add a convenient (albeit wrong)
> ## S3-method for vcov:
> ## --- wrong as in general cov-matrix
> ##     will not be diagonal
> ## but for conf-interval this does
> ## not matter...
> vcov.fitdistr <- function(object, ...){
+      v<-diag(object$sd^2)
+      rownames(v) <- colnames(v) <- names(object$estimate) 
+      v}
> 
> ## explicitely transforming to
> ## MASS parametrization:
> mtrafo <- function(x){
+      nms0 <- names(c(main(param(G)),nuisance(param(G))))
+      nms <- c("shape","rate")
+      fval0 <- c(x[2], 1/x[1])
+      names(fval0) <- nms
+      mat0 <- matrix( c(0, -1/x[1]^2, 1, 0), nrow = 2, ncol = 2,
+                      dimnames = list(nms,nms0))                          
+      list(fval = fval0, mat = mat0)}
> 
> G2 <- G
> trafo(G2) <- mtrafo
> res2 <- MLEstimator(x = x, ParamFamily = G2)
> 
> old<-getdistrModOption("show.details")
> distrModoptions("show.details" = "minimal")
> res
Evaluations of Maximum likelihood estimate:
-------------------------------------------
     scale        shape   
  0.34200800   4.06028564 
 (0.07002713) (0.78099026)
> res1
     shape       rate   
  4.0606867   2.9242396 
 (0.7810673) (0.5987423)
> res2
Evaluations of Maximum likelihood estimate:
-------------------------------------------
     shape       rate   
  4.0602856   2.9239082 
 (0.7809903) (0.5986786)
> confint(res)
A[n] asymptotic (CLT-based) confidence interval:
          2.5 %    97.5 %
scale 0.2047574 0.4792587
shape 2.5295729 5.5909984
> confint(res1)
         2.5 %   97.5 %
shape 2.529823 5.591550
rate  1.750726 4.097753
> confint(res2)
A[n] asymptotic (CLT-based) confidence interval:
         2.5 %   97.5 %
shape 2.529573 5.590998
rate  1.750520 4.097297
> confint(res,level=0.99)
A[n] asymptotic (CLT-based) confidence interval:
          0.5 %    99.5 %
scale 0.1616301 0.5223859
shape 2.0485880 6.0719832
> distrModoptions("show.details" = old)
>  
> 
> 
> 
> cleanEx()
> nameEx("distrModMASK")
> ### * distrModMASK
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: distrModMASK
> ### Title: Masking of/by other functions in package "distrMod"
> ### Aliases: distrModMASK MASKING
> ### Keywords: programming distribution documentation
> 
> ### ** Examples
> 
> distrModMASK()
######################################################################
#  On masking of and by other functions in package "distrMod"       
######################################################################

Attention:

*** intentional masking: ***

To be able to use the same symbol for objects of S4-classes 'Estimate',
we intentionally mask the following function[s] --- however this/these 
function[s] may still be used in exactly the same way as before 
masking:

+confint()    (package "stats")
 
 

> 
> 
> 
> cleanEx()
> nameEx("distrModOptions")
> ### * distrModOptions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: distrModOptions
> ### Title: Function to change the global variables of the package
> ###   'distrMod'
> ### Aliases: distrModOptions getdistrModOption distrModoptions show.details
> ### Keywords: misc distribution
> 
> ### ** Examples
> 
> distrModoptions()
$show.details
[1] "minimal"

> distrModoptions("show.details")
$show.details
[1] "minimal"

> distrModoptions("show.details" = "maximal")
> distrModOptions("show.details" = "minimal")
> # or
> getdistrModOption("show.details")
[1] "minimal"
> 
> 
> 
> cleanEx()
> nameEx("fiBias-class")
> ### * fiBias-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fiBias-class
> ### Title: Finite-sample Bias
> ### Aliases: fiBias-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("fiBias")
An object of class “fiBias” 
risk type:	 finite-sample bias 
> 
> 
> 
> cleanEx()
> nameEx("fiBias")
> ### * fiBias
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fiBias
> ### Title: Generating function for fiBias-class
> ### Aliases: fiBias
> ### Keywords: robust
> 
> ### ** Examples
> 
> fiBias()
An object of class “fiBias” 
risk type:	 finite-sample bias 
> 
> ## The function is currently defined as
> function(){ new("fiBias") }
function () 
{
    new("fiBias")
}
> 
> 
> 
> cleanEx()
> nameEx("fiCov-class")
> ### * fiCov-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fiCov-class
> ### Title: Finite-sample covariance
> ### Aliases: fiCov-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("fiCov")
An object of class “fiCov” 
risk type:	 finite-sample covariance 
> 
> 
> 
> cleanEx()
> nameEx("fiCov")
> ### * fiCov
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fiCov
> ### Title: Generating function for fiCov-class
> ### Aliases: fiCov
> ### Keywords: robust
> 
> ### ** Examples
> 
> fiCov()
An object of class “fiCov” 
risk type:	 finite-sample covariance 
> 
> ## The function is currently defined as
> function(){ new("fiCov") }
function () 
{
    new("fiCov")
}
> 
> 
> 
> cleanEx()
> nameEx("fiHampel-class")
> ### * fiHampel-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fiHampel-class
> ### Title: Finite-sample Hampel risk
> ### Aliases: fiHampel-class bound,fiHampel-method show,fiHampel-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("fiHampel")
An object of class “fiHampel” 
risk type:	 finite-sample variance for given bias bound 
bound:	 Inf 
> 
> 
> 
> cleanEx()
> nameEx("fiHampel")
> ### * fiHampel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fiHampel
> ### Title: Generating function for fiHampel-class
> ### Aliases: fiHampel
> ### Keywords: robust
> 
> ### ** Examples
> 
> fiHampel()
An object of class “fiHampel” 
risk type:	 finite-sample variance for given bias bound 
bound:	 Inf 
> 
> ## The function is currently defined as
> function(bound = Inf){ new("fiHampel", bound = bound) }
function (bound = Inf) 
{
    new("fiHampel", bound = bound)
}
> 
> 
> 
> cleanEx()
> nameEx("fiMSE-class")
> ### * fiMSE-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fiMSE-class
> ### Title: Finite-sample mean square error
> ### Aliases: fiMSE-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("fiMSE")
An object of class “fiMSE” 
risk type:	 finite-sample mean square error 
> 
> 
> 
> cleanEx()
> nameEx("fiMSE")
> ### * fiMSE
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fiMSE
> ### Title: Generating function for fiMSE-class
> ### Aliases: fiMSE
> ### Keywords: robust
> 
> ### ** Examples
> 
> fiMSE()
An object of class “fiMSE” 
risk type:	 finite-sample mean square error 
> 
> ## The function is currently defined as
> function(){ new("fiMSE") }
function () 
{
    new("fiMSE")
}
> 
> 
> 
> cleanEx()
> nameEx("fiUnOvShoot-class")
> ### * fiUnOvShoot-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fiUnOvShoot-class
> ### Title: Finite-sample under-/overshoot probability
> ### Aliases: fiUnOvShoot-class width,fiUnOvShoot-method
> ###   show,fiUnOvShoot-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("fiUnOvShoot")
An object of class “fiUnOvShoot” 
risk type:	 finite-sample under-/overshoot probability 
width:	  
> 
> 
> 
> cleanEx()
> nameEx("fiUnOvShoot")
> ### * fiUnOvShoot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fiUnOvShoot
> ### Title: Generating function for fiUnOvShoot-class
> ### Aliases: fiUnOvShoot
> ### Keywords: robust
> 
> ### ** Examples
> 
> fiUnOvShoot()
An object of class “fiUnOvShoot” 
risk type:	 finite-sample under-/overshoot probability 
width:	 1.96 
> 
> ## The function is currently defined as
> function(width = 1.960){ new("fiUnOvShoot", width = width) }
function (width = 1.96) 
{
    new("fiUnOvShoot", width = width)
}
> 
> 
> 
> cleanEx()
> nameEx("isKerAinKerB")
> ### * isKerAinKerB
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: isKerAinKerB
> ### Title: isKerAinKerB
> ### Aliases: isKerAinKerB
> ### Keywords: algebra array
> 
> ### ** Examples
> 
> ma <- cbind(1,1,c(1,1,7))
> D <- t(ma %*% c(0,1,-1))
> isKerAinKerB(D,ma)
[1] FALSE
> isKerAinKerB(ma,D)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("negativeBias")
> ### * negativeBias
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: negativeBias
> ### Title: Generating function for onesidedBias-class
> ### Aliases: negativeBias
> ### Keywords: robust
> 
> ### ** Examples
> 
> negativeBias()
An object of class "onesidedBias"
Slot "sign":
[1] -1

Slot "name":
[1] "negative Bias"

> 
> ## The function is currently defined as
> function(){ new("onesidedBias", name = "negative Bias", sign = -1) }
function () 
{
    new("onesidedBias", name = "negative Bias", sign = -1)
}
> 
> 
> 
> cleanEx()
> nameEx("norms")
> ### * norms
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: norm
> ### Title: Norm functions
> ### Aliases: EuclideanNorm QuadFormNorm
> ### Keywords: robust
> 
> ### ** Examples
> 
> mm <- matrix(rnorm(20),2,10)
> EuclideanNorm(mm)
 [1] 0.6528164 1.8008876 0.8841627 0.8847092 0.6517563 1.5612367 2.3001816
 [8] 1.1258280 0.9439751 1.0134708
> QuadFormNorm(mm, A = PosSemDefSymmMatrix(matrix(c(3,1,1,1),2,2)))
 [1] 0.9904392 1.4048565 0.6768996 1.4062882 0.8579981 2.8613179 2.9689119
 [8] 1.9228451 0.9279285 1.8306775
> 
> 
> 
> cleanEx()
> nameEx("onesidedBias-class")
> ### * onesidedBias-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: onesidedBias-class
> ### Title: onesided Bias Type
> ### Aliases: onesidedBias-class sign sign<- sign,onesidedBias-method
> ###   sign<-,onesidedBias-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> positiveBias()
An object of class "onesidedBias"
Slot "sign":
[1] 1

Slot "name":
[1] "positive Bias"

> ## The function is currently defined as
> function(){ new("onesidedBias", name = "positive Bias", sign = 1) }
function () 
{
    new("onesidedBias", name = "positive Bias", sign = 1)
}
> 
> negativeBias()
An object of class "onesidedBias"
Slot "sign":
[1] -1

Slot "name":
[1] "negative Bias"

> ## The function is currently defined as
> function(){ new("onesidedBias", name = "negative Bias", sign = -1) }
function () 
{
    new("onesidedBias", name = "negative Bias", sign = -1)
}
> 
> pB <- positiveBias()
> sign(pB)
[1] 1
> try(sign(pB) <- -2) ## error
Error in `sign<-`(`*tmp*`, value = -2) : Left value has to be +-1
> sign(pB) <- -1
> 
> 
> 
> cleanEx()
> nameEx("positiveBias")
> ### * positiveBias
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: positiveBias
> ### Title: Generating function for onesidedBias-class
> ### Aliases: positiveBias
> ### Keywords: robust
> 
> ### ** Examples
> 
> positiveBias()
An object of class "onesidedBias"
Slot "sign":
[1] 1

Slot "name":
[1] "positive Bias"

> 
> ## The function is currently defined as
> function(){ new("onesidedBias", name = "positive Bias", sign = 1) }
function () 
{
    new("onesidedBias", name = "positive Bias", sign = 1)
}
> 
> 
> 
> cleanEx()
> nameEx("print-methods")
> ### * print-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print-methods
> ### Title: Common 'print' Methods for S4 classes in Package 'distrMod'
> ### Aliases: print-methods print,ShowDetails-method
> ### Keywords: models
> 
> ### ** Examples
> 
> ## set options to maximal detailedness
> show.old <- getdistrModOption("show.details")
> distrModoptions("show.details" = "maximal")
> ## define a model
> NS <- NormLocationScaleFamily(mean=2, sd=3)
> ## generate data out of this situation
> x <- r(distribution(NS))(30)
> 
> ## want to estimate mu/sigma, sigma^2
> ## -> new trafo slot:
> trafo(NS) <- function(param){
+   mu <- param["mean"]
+   sd <- param["sd"]
+   fval <- c(mu/sd, sd^2)
+   nfval <- c("mu/sig", "sig^2")
+   names(fval) <- nfval
+   mat <- matrix(c(1/sd,0,-mu/sd^2,2*sd),2,2)
+   dimnames(mat) <- list(nfval,c("mean","sd"))
+   return(list(fval=fval, mat=mat))
+ }
> print(param(NS))
An object of class "ParamWithScaleFamParameter"
name:	location and scale
mean:	2
sd:	3
trafo:
function (param) 
{
    mu <- param["mean"]
    sd <- param["sd"]
    fval <- c(mu/sd, sd^2)
    nfval <- c("mu/sig", "sig^2")
    names(fval) <- nfval
    mat <- matrix(c(1/sd, 0, -mu/sd^2, 2 * sd), 2, 2)
    dimnames(mat) <- list(nfval, c("mean", "sd"))
    return(list(fval = fval, mat = mat))
}
<bytecode: 0xb1aa450>
> print(param(NS), show.details = "minimal")
An object of class "ParamWithScaleFamParameter"
name:	location and scale
mean:	2
sd:	3
> print(param(NS), show.details = "medium")
An object of class "ParamWithScaleFamParameter"
name:	location and scale
mean:	2
sd:	3
slot trafo is a non-trivial function
> ## Maximum likelihood estimator
> res <- MLEstimator(x = x, ParamFamily = NS)
> print(res) #equivalent to 'show(res)' or 'res'
Evaluations of Maximum likelihood estimate:
-------------------------------------------
An object of class “Estimate” 
generated by call
  MLEstimator(x = x, ParamFamily = NS)
samplesize:   30
estimate:
    mu/sig       sig^2  
  0.8244932   7.4297939 
 (0.2113366) (1.9183645)
asymptotic (co)variance (multiplied with samplesize):
          mu/sig      sig^2
mu/sig  1.339895  -6.125814
sig^2  -6.125814 110.403676
untransformed estimate:
     mean         sd    
  2.2473745   2.7257648 
 (0.4976543) (0.3518947)
asymptotic (co)variance of untransformed estimate (multiplied with samplesize):
         mean       sd
mean 7.429794 0.000000
sd   0.000000 3.714897
Transformation of main parameter:
function (param) 
{
    mu <- param["mean"]
    sd <- param["sd"]
    fval <- c(mu/sd, sd^2)
    nfval <- c("mu/sig", "sig^2")
    names(fval) <- nfval
    mat <- matrix(c(1/sd, 0, -mu/sd^2, 2 * sd), 2, 2)
    dimnames(mat) <- list(nfval, c("mean", "sd"))
    return(list(fval = fval, mat = mat))
}
<bytecode: 0xb1aa450>
Trafo / derivative matrix:
            mean         sd
mu/sig 0.3668695 -0.3024814
sig^2  0.0000000  5.4515297
Criterion:
negative log-likelihood 
               72.65063 
> print(res, digits = 4)
Evaluations of Maximum likelihood estimate:
-------------------------------------------
An object of class “Estimate” 
generated by call
  MLEstimator(x = x, ParamFamily = NS)
samplesize:   30
estimate:
   mu/sig    sig^2 
  0.8245    7.4298 
 (0.2113)  (1.9184)
asymptotic (co)variance (multiplied with samplesize):
       mu/sig   sig^2
mu/sig  1.340  -6.126
sig^2  -6.126 110.404
untransformed estimate:
    mean      sd  
  2.2474   2.7258 
 (0.4977) (0.3519)
asymptotic (co)variance of untransformed estimate (multiplied with samplesize):
     mean    sd
mean 7.43 0.000
sd   0.00 3.715
Transformation of main parameter:
function (param) 
{
    mu <- param["mean"]
    sd <- param["sd"]
    fval <- c(mu/sd, sd^2)
    nfval <- c("mu/sig", "sig^2")
    names(fval) <- nfval
    mat <- matrix(c(1/sd, 0, -mu/sd^2, 2 * sd), 2, 2)
    dimnames(mat) <- list(nfval, c("mean", "sd"))
    return(list(fval = fval, mat = mat))
}
<bytecode: 0xb1aa450>
Trafo / derivative matrix:
         mean      sd
mu/sig 0.3669 -0.3025
sig^2  0.0000  5.4515
Criterion:
negative log-likelihood 
                  72.65 
> print(res, show.details = "minimal")
Evaluations of Maximum likelihood estimate:
-------------------------------------------
    mu/sig       sig^2  
  0.8244932   7.4297939 
 (0.2113366) (1.9183645)
> print(res, show.details = "medium")
Evaluations of Maximum likelihood estimate:
-------------------------------------------
An object of class “Estimate” 
generated by call
  MLEstimator(x = x, ParamFamily = NS)
samplesize:   30
estimate:
    mu/sig       sig^2  
  0.8244932   7.4297939 
 (0.2113366) (1.9183645)
asymptotic (co)variance (multiplied with samplesize):
          mu/sig      sig^2
mu/sig  1.339895  -6.125814
sig^2  -6.125814 110.403676
Criterion:
negative log-likelihood 
               72.65063 
> distrModoptions("show.details" = show.old)
> 
> 
> 
> cleanEx()
> nameEx("qqplot")
> ### * qqplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: qqplot
> ### Title: Methods for Function qqplot in Package 'distrMod'
> ### Aliases: qqplot qqplot-methods qqplot,ANY,ProbFamily-method
> ###   qqplot,ANY,Estimate-method qqplot,ANY,UnivariateDistribution-method
> ### Keywords: hplot distribution
> 
> ### ** Examples
> 
> set.seed(123)
> x <- rnorm(40,mean=15,sd=30)
> qqplot(x, Chisq(df=15))
> NF <- NormLocationScaleFamily(mean=15, sd=30)
> qqplot(x, NF, with.lab=TRUE, which.Order=1:5, cex.lbs=1.3)
> mlE <- MLEstimator(x, NF)
> qqplot(x, mlE)
> 
> 
> 
> cleanEx()
> nameEx("returnlevelplot")
> ### * returnlevelplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: returnlevelplot
> ### Title: Methods for Function returnlevelplot in Package 'distrMod'
> ### Aliases: returnlevelplot returnlevelplot-methods
> ###   returnlevelplot,ANY,ProbFamily-method
> ###   returnlevelplot,ANY,UnivariateDistribution-method
> ###   returnlevelplot,ANY,Estimate-method
> ### Keywords: hplot distribution
> 
> ### ** Examples
> 
> returnlevelplot(r(Norm(15,sqrt(30)))(40), Chisq(df=15))
> ### more could be seen after installing RobExtremes and ismev
> #
> if(require(RobExtremes) && require(ismev)){
+ 
+  data(portpirie)
+  gevfit <- gev.fit(portpirie[,2]) ## taken from example from ismev::gev.fit
+  GEVF <- GEVFamily(scale=gevfit$mle[2],shape=gevfit$mle[3],loc=gevfit$mle[1])
+  erg <- returnlevelplot(portpirie[,2], GEVF)
+  print(erg)
+  returnlevelplot(portpirie[,2], GEVF, datax=TRUE)
+ 
+  data(rain)
+  gpdfit <- gpd.fit(rain,10) ## taken from example from ismev::gpd.fit
+  GPDF <- GParetoFamily(scale=gpdfit$mle[1],shape=gpdfit$mle[2],loc=10)
+  returnlevelplot(rain, GPDF, MaxOrPOT="POT", xlim=c(1e-1,1e3))
+ }
Loading required package: RobExtremes
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘RobExtremes’
> 
> 
> cleanEx()
> nameEx("symmetricBias-class")
> ### * symmetricBias-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: symmetricBias-class
> ### Title: symmetric Bias Type
> ### Aliases: symmetricBias-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> symmetricBias()
An object of class "symmetricBias"
Slot "name":
[1] "symmetric Bias"

> ## The function is currently defined as
> function(){ new("symmetricBias", name = "symmetric Bias") }
function () 
{
    new("symmetricBias", name = "symmetric Bias")
}
> 
> 
> 
> cleanEx()
> nameEx("symmetricBias")
> ### * symmetricBias
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: symmetricBias
> ### Title: Generating function for symmetricBias-class
> ### Aliases: symmetricBias
> ### Keywords: robust
> 
> ### ** Examples
> 
> symmetricBias()
An object of class "symmetricBias"
Slot "name":
[1] "symmetric Bias"

> 
> ## The function is currently defined as
> function(){ new("symmetricBias", name = "symmetric Bias") }
function () 
{
    new("symmetricBias", name = "symmetric Bias")
}
> 
> 
> 
> cleanEx()
> nameEx("trAsCov-class")
> ### * trAsCov-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trAsCov-class
> ### Title: Trace of asymptotic covariance
> ### Aliases: trAsCov-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("trAsCov")
An object of class “trAsCov” 
risk type:	 trace of asymptotic covariance 
> 
> 
> 
> cleanEx()
> nameEx("trAsCov")
> ### * trAsCov
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trAsCov
> ### Title: Generating function for trAsCov-class
> ### Aliases: trAsCov
> ### Keywords: robust
> 
> ### ** Examples
> 
> trAsCov()
An object of class “trAsCov” 
risk type:	 trace of asymptotic covariance 
> 
> ## The function is currently defined as
> function(){ new("trAsCov") }
function () 
{
    new("trAsCov")
}
> 
> 
> 
> cleanEx()
> nameEx("trFiCov-class")
> ### * trFiCov-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trFiCov-class
> ### Title: Trace of finite-sample covariance
> ### Aliases: trFiCov-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("trFiCov")
An object of class “trFiCov” 
risk type:	 trace of finite-sample covariance 
> 
> 
> 
> cleanEx()
> nameEx("trFiCov")
> ### * trFiCov
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trFiCov
> ### Title: Generating function for trFiCov-class
> ### Aliases: trFiCov
> ### Keywords: robust
> 
> ### ** Examples
> 
> trFiCov()
An object of class “trFiCov” 
risk type:	 trace of finite-sample covariance 
> 
> ## The function is currently defined as
> function(){ new("trFiCov") }
function () 
{
    new("trFiCov")
}
> 
> 
> 
> cleanEx()
> nameEx("trafo-methods")
> ### * trafo-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trafo-methods
> ### Title: Methods for function trafo in Package 'distrMod'
> ### Aliases: trafo-methods trafo trafo,Estimate,missing-method
> ###   trafo,Estimate,ParamFamParameter-method
> ###   trafo,ParamFamParameter,missing-method
> ###   trafo,ParamWithScaleAndShapeFamParameter,missing-method
> ###   trafo,ParamFamily,missing-method
> ###   trafo,ParamFamily,ParamFamParameter-method trafo.fct
> ###   trafo.fct-methods trafo.fct,ParamFamily-method trafo<-
> ###   trafo<-,ParamFamParameter-method trafo<-,ParamFamily-method
> ### Keywords: models
> 
> ### ** Examples
> 
> ## Gaussian location and scale
> NS <- NormLocationScaleFamily(mean=2, sd=3)
> ## generate data out of this situation
> x <- r(distribution(NS))(30)
> 
> ## want to estimate mu/sigma, sigma^2
> ## -> new trafo slot:
> trafo(NS) <- function(param){
+   mu <- param["mean"]
+   sd <- param["sd"]
+   fval <- c(mu/sd, sd^2)
+   nfval <- c("mu/sig", "sig^2")
+   names(fval) <- nfval
+   mat <- matrix(c(1/sd,0,-mu/sd^2,2*sd),2,2)
+   dimnames(mat) <- list(nfval,c("mean","sd"))
+   return(list(fval=fval, mat=mat))
+ }
> 
> ## Maximum likelihood estimator
> (res <- MLEstimator(x = x, ParamFamily = NS))
Evaluations of Maximum likelihood estimate:
-------------------------------------------
    mu/sig       sig^2  
  0.8244932   7.4297939 
 (0.2113366) (1.9183645)
> ## confidence interval
>  confint(res)
A[n] asymptotic (CLT-based) confidence interval:
           2.5 %    97.5 %
mu/sig 0.4102811  1.238705
sig^2  3.6698685 11.189719
> 
> 
> 
> 
> cleanEx()
> nameEx("trafoEst")
> ### * trafoEst
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trafoEst
> ### Title: Function trafoEst in Package 'distrMod'
> ### Aliases: trafoEst
> ### Keywords: models
> 
> ### ** Examples
> 
> ## Gaussian location and scale
> NS <- NormLocationScaleFamily(mean=2, sd=3)
> ## generate data out of this situation
> x <- r(distribution(NS))(30)
> 
> ## want to estimate mu/sigma, sigma^2
> ## -> without new trafo slot:
> mtrafo <- function(param){
+   mu <- param["mean"]
+   sd <- param["sd"]
+   fval <- c(mu/sd, sd^2)
+   nfval <- c("mu/sig", "sig^2")
+   names(fval) <- nfval
+   mat <- matrix(c(1/sd,0,-mu/sd^2,2*sd),2,2)
+   dimnames(mat) <- list(nfval,c("mean","sd"))
+   return(list(fval=fval, mat=mat))
+ }
> 
> ## Maximum likelihood estimator in the original problem
> res0 <- MLEstimator(x = x, ParamFamily = NS)
> ## transformation
> res <- trafoEst(mtrafo, res0)
> ## confidence interval
>  confint(res)
A[n] asymptotic (CLT-based) confidence interval:
           2.5 %    97.5 %
mu/sig 0.4102811  1.238705
sig^2  3.6698685 11.189719
> 
> 
> 
> cleanEx()
> nameEx("validParameter-methods")
> ### * validParameter-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: validParameter-methods
> ### Title: Methods for function validParameter in Package 'distrMod'
> ### Aliases: validParameter-methods validParameter
> ###   validParameter,ParamFamily-method validParameter,L2ScaleUnion-method
> ###   validParameter,L2ScaleFamily-method
> ###   validParameter,L2LocationFamily-method
> ###   validParameter,L2LocationScaleFamily-method
> ###   validParameter,BinomFamily-method validParameter,PoisFamily-method
> ###   validParameter,L2ScaleShapeUnion-method
> ### Keywords: models
> 
> ### ** Examples
> 
>  NS <- NormLocationScaleFamily()
>  validParameter(NS, c(scale=0.1, loc=2))
[1] TRUE
>  validParameter(NS, c(scale=-0.1, loc=2))
[1] FALSE
>  validParameter(NS, c(scale=0, loc=2))
[1] FALSE
>  validParameter(NS, c(mean=2, sd=2))
[1] TRUE
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  31.872 0.196 32.183 0 0.008 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
