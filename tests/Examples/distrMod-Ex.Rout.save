
R Under development (unstable) (2020-03-05 r77909) -- "Unsuffered Consequences"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: i386-w64-mingw32/i386 (32-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "distrMod"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> options(pager = "console")
> library('distrMod')
Loading required package: distr
Loading required package: startupmsg
:startupmsg>  Utilities for Start-Up Messages (version 0.9.6)
:startupmsg> 
:startupmsg>  For more information see ?"startupmsg",
:startupmsg>  NEWS("startupmsg")

Loading required package: sfsmisc
:distr>  Object Oriented Implementation of Distributions (version
:distr>  2.8.0)
:distr> 
:distr>  Attention: Arithmetics on distribution objects are
:distr>  understood as operations on corresponding random variables
:distr>  (r.v.s); see distrARITH().
:distr> 
:distr>  Some functions from package 'stats' are intentionally masked
:distr>  ---see distrMASK().
:distr> 
:distr>  Note that global options are controlled by distroptions()
:distr>  ---c.f. ?"distroptions".
:distr> 
:distr>  For more information see ?"distr", NEWS("distr"), as well as
:distr>    http://distr.r-forge.r-project.org/
:distr>  Package "distrDoc" provides a vignette to this package as
:distr>  well as to several extension packages; try
:distr>  vignette("distr").


Attaching package: 'distr'

The following objects are masked from 'package:stats':

    df, qqplot, sd

Loading required package: distrEx
:distrEx>  Extensions of Package 'distr' (version 2.8.0)
:distrEx> 
:distrEx>  Note: Packages "e1071", "moments", "fBasics" should be
:distrEx>  attached /before/ package "distrEx". See
:distrEx>  distrExMASK().Note: Extreme value distribution
:distrEx>  functionality has been moved to
:distrEx> 
:distrEx>        package "RobExtremes". See distrExMOVED().
:distrEx> 
:distrEx>  For more information see ?"distrEx", NEWS("distrEx"), as
:distrEx>  well as
:distrEx>    http://distr.r-forge.r-project.org/
:distrEx>  Package "distrDoc" provides a vignette to this package
:distrEx>  as well as to several related packages; try
:distrEx>  vignette("distr").


Attaching package: 'distrEx'

The following objects are masked from 'package:stats':

    IQR, mad, median, var

Loading required package: RandVar
:RandVar>  Implementation of Random Variables (version 1.2.1)
:RandVar> 
:RandVar>  For more information see ?"RandVar", NEWS("RandVar"), as
:RandVar>  well as
:RandVar>    http://robast.r-forge.r-project.org/
:RandVar>  This package also includes a vignette; try
:RandVar>  vignette("RandVar").

Loading required package: MASS
Loading required package: stats4
:distrMod>  Object Oriented Implementation of Probability Models
:distrMod>  (version 2.8.4)
:distrMod> 
:distrMod>  Some functions from pkg's 'base' and 'stats' are
:distrMod>  intentionally masked ---see distrModMASK().
:distrMod> 
:distrMod>  Note that global options are controlled by
:distrMod>  distrModoptions() ---c.f. ?"distrModoptions".
:distrMod> 
:distrMod>  For more information see ?"distrMod",
:distrMod>  NEWS("distrMod"), as well as
:distrMod>    http://distr.r-forge.r-project.org/
:distrMod>  There is a vignette to this package; try
:distrMod>  vignette("distrMod").
:distrMod>  Package "distrDoc" provides a vignette to the other
:distrMod>  distrXXX packages,
:distrMod>  as well as to several related packages; try
:distrMod>  vignette("distr").


Attaching package: 'distrMod'

The following object is masked from 'package:stats4':

    confint

The following object is masked from 'package:stats':

    confint

The following object is masked from 'package:base':

    norm

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("BetaFamily")
> ### * BetaFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: BetaFamily
> ### Title: Generating function for Beta families
> ### Aliases: BetaFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (B1 <- BetaFamily())
An object of class "BetaFamily"
### name:	Beta family

### distribution:	Distribution Object of Class: Beta
 shape1: 1
 shape2: 1
 ncp: 0

### param:	An object of class "ParamFamParameter"
name:	shape1 and shape2
shape1:	1
shape2:	1
trafo:
       shape1 shape2
shape1      1      0
shape2      0      1

### props:
[1] "The Beta family is invariant in the following sense"
[2] "if (x_i)~Beta(s1,s2) then (1-x_i)~Beta(s2,s1)"      
> FisherInfo(B1)
An object of class "PosSemDefSymmMatrix"
           shape1     shape2
shape1  1.0000000 -0.6449341
shape2 -0.6449341  1.0000000
> ## IGNORE_RDIFF_BEGIN
> checkL2deriv(B1)
precision of centering:	 3.96327e-05 3.963591e-05 
precision of Fisher information:
            shape1      shape2
shape1 -1.8511e-05  1.6483e-06
shape2  1.6483e-06 -1.8511e-05
precision of Fisher information - relativ error [%]:
     [,1]      [,2]     
[1,] -1.85e-03 -2.56e-04
[2,] -2.56e-04 -1.85e-03
condition of Fisher information:
[1] 5.2777
> ## IGNORE_RDIFF_END
> 
> 
> 
> cleanEx()
> nameEx("BiasType-class")
> ### * BiasType-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: BiasType-class
> ### Title: Bias Type
> ### Aliases: BiasType-class name,BiasType-method name<-,BiasType-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> aB <- positiveBias()
> name(aB)
[1] "positive Bias"
> 
> 
> 
> cleanEx()
> nameEx("BinomFamily")
> ### * BinomFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: BinomFamily
> ### Title: Generating function for Binomial families
> ### Aliases: BinomFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (B1 <- BinomFamily(size = 25, prob = 0.25))
An object of class "BinomFamily"
### name:	Binomial family

### distribution:	Distribution Object of Class: Binom
 size: 25
 prob: 0.25

### param:	An object of class "ParamFamParameter"
name:	probability of success
prob:	0.25
fixed part of param.:
	size:	25
trafo:
     prob
prob    1

### props:
[1] "The Binomial family is symmetric with respect to prob = 0.5;"
[2] "i.e., d(Binom(size, prob))(k)=d(Binom(size,1-prob))(size-k)" 
> plot(B1)
> FisherInfo(B1)
An object of class "PosSemDefSymmMatrix"
         prob
prob 133.3333
> checkL2deriv(B1)
precision of centering:	 0 
precision of Fisher information:
     prob
prob    0
precision of Fisher information - relativ error [%]:
     [,1] 
[1,] 0.000
condition of Fisher information:
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("CauchyLocationFamily")
> ### * CauchyLocationFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CauchyLocationFamily
> ### Title: Generating function for Cauchy location families
> ### Aliases: CauchyLocationFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (C1 <- CauchyLocationFamily())
An object of class "CauchyLocationFamily"
### name:	Cauchy location family

### distribution:	Distribution Object of Class: Cauchy
 location: 0
 scale: 1

### param:	An object of class "ParamFamParameter"
name:	loc
loc:	0
trafo:
    loc
loc   1

### props:
[1] "The Cauchy location family is invariant under"
[2] "the group of transformations 'g(x) = x + loc'"
[3] "with location parameter 'loc'"                
> plot(C1)
> FisherInfo(C1)
An object of class "PosDefSymmMatrix"
    loc
loc 0.5
> ### need smaller integration range:
> checkL2deriv(C1)
precision of centering:	 0 
precision of Fisher information:
    loc
loc   0
precision of Fisher information - relativ error [%]:
     [,1]    
[1,] -2.1e-11
condition of Fisher information:
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("CauchyLocationScaleFamily")
> ### * CauchyLocationScaleFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CauchyLocationScaleFamily
> ### Title: Generating function for Cauchy location and scale families
> ### Aliases: CauchyLocationScaleFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (C1 <- CauchyLocationScaleFamily())
An object of class "CauchyLocationScaleFamily"
### name:	Cauchy Location and scale family

### distribution:	Distribution Object of Class: Cauchy
 location: 0
 scale: 1

### param:	An object of class "ParamWithScaleFamParameter"
name:	location and scale
loc:	0
scale:	1
trafo:
      loc scale
loc     1     0
scale   0     1

### props:
[1] "The Cauchy Location and scale family is invariant under"  
[2] "the group of transformations 'g(x) = scale*x + loc'"      
[3] "with location parameter 'loc' and scale parameter 'scale'"
> plot(C1)
> FisherInfo(C1)
An object of class "PosDefSymmMatrix"
      loc scale
loc   0.5   0.0
scale 0.0   0.5
> ### need smaller integration range:
> distrExoptions("ElowerTruncQuantile"=1e-4,"EupperTruncQuantile"=1e-4)
> checkL2deriv(C1)
precision of centering:	 0 -2e-04 
precision of Fisher information:
           loc  scale
loc   -2.6e-11  0e+00
scale  0.0e+00 -2e-04
precision of Fisher information - relativ error [%]:
     [,1]      [,2]     
[1,] -5.26e-09 .        
[2,] .         -4.00e-02
condition of Fisher information:
[1] 1
> distrExoptions("ElowerTruncQuantile"=1e-7,"EupperTruncQuantile"=1e-7)
> 
> 
> 
> cleanEx()
> nameEx("Confint-class")
> ### * Confint-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Confint-class
> ### Title: Confint-class
> ### Aliases: Confint-class type,Confint-method call.estimate
> ###   call.estimate,Confint-method confint,Confint,missing-method
> ###   name.estimate name.estimate,Confint-method trafo.estimate
> ###   trafo.estimate,Confint-method samplesize.estimate
> ###   samplesize.estimate,Confint-method completecases.estimate
> ###   completecases.estimate,Confint-method nuisance.estimate
> ###   nuisance.estimate,Confint-method fixed.estimate
> ###   fixed.estimate,Confint-method show,Confint-method
> ###   print,Confint-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## some transformation
> mtrafo <- function(x){
+      nms0 <- c("scale","shape")
+      nms <- c("shape","rate")
+      fval0 <- c(x[2], 1/x[1])
+      names(fval0) <- nms
+      mat0 <- matrix( c(0, -1/x[1]^2, 1, 0), nrow = 2, ncol = 2,
+                      dimnames = list(nms,nms0))                          
+      list(fval = fval0, mat = mat0)}
> 
> x <- rgamma(50, scale = 0.5, shape = 3)
> 
> ## parametric family of probability measures
> G <- GammaFamily(scale = 1, shape = 2, trafo = mtrafo)
> ## MLE
> res <- MLEstimator(x = x, ParamFamily = G)
> ci <- confint(res)
> print(ci, digits = 4, show.details="maximal")
A[n] asymptotic (CLT-based) confidence interval:
      2.5 % 97.5 %
shape 2.530  5.591
rate  1.751  4.097
Type of estimator: Maximum likelihood estimate
samplesize:   50
Call by which estimate was produced:
MLEstimator(x = x, ParamFamily = G)
Transformation of main parameter by which estimate was produced:
function (x) 
{
    nms0 <- c("scale", "shape")
    nms <- c("shape", "rate")
    fval0 <- c(x[2], 1/x[1])
    names(fval0) <- nms
    mat0 <- matrix(c(0, -1/x[1]^2, 1, 0), nrow = 2, ncol = 2, 
        dimnames = list(nms, nms0))
    list(fval = fval0, mat = mat0)
}
<bytecode: 0x0bc6d9d0>
Trafo / derivative matrix at which estimate was produced:
       scale shape
shape  0.000     1
rate  -8.549     0
> print(ci, digits = 4, show.details="medium")
A[n] asymptotic (CLT-based) confidence interval:
      2.5 % 97.5 %
shape 2.530  5.591
rate  1.751  4.097
Type of estimator: Maximum likelihood estimate
samplesize:   50
Call by which estimate was produced:
MLEstimator(x = x, ParamFamily = G)
> print(ci, digits = 4, show.details="minimal")
A[n] asymptotic (CLT-based) confidence interval:
      2.5 % 97.5 %
shape 2.530  5.591
rate  1.751  4.097
> 
> 
> 
> cleanEx()
> nameEx("Estimate-class")
> ### * Estimate-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Estimate-class
> ### Title: Estimate-class.
> ### Aliases: Estimate-class name,Estimate-method name<-,Estimate-method
> ###   estimate estimate,Estimate-method estimate.call
> ###   estimate.call,Estimate-method Infos Infos,Estimate-method samplesize
> ###   samplesize,Estimate-method completecases
> ###   completecases,Estimate-method asvar asvar,Estimate-method
> ###   fixed,Estimate-method asvar<- asvar<-,Estimate-method
> ###   nuisance,Estimate-method main,Estimate-method Infos<-
> ###   Infos<-,Estimate-method addInfo<- addInfo<-,Estimate-method
> ###   show,Estimate-method print,Estimate-method untransformed.estimate
> ###   untransformed.estimate,Estimate-method untransformed.asvar
> ###   untransformed.asvar,Estimate-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> x <- rnorm(100)
> Estimator(x, estimator = mean, name = "mean")
Evaluations of mean:
--------------------
An object of class "Estimate" 
generated by call
  Estimator(x = x, estimator = mean, name = "mean")
samplesize:   100
estimate:
    mean1 
0.1088874 
> 
> x1 <- x; x1[sample(1:100,10)] <- NA
> myEst1 <- Estimator(x1, estimator = mean, name = "mean")
> samplesize(myEst1)
[1] 90
> samplesize(myEst1, onlycomplete = FALSE)
[1] 100
> 
> 
> 
> cleanEx()
> nameEx("Estimator")
> ### * Estimator
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Estimator
> ### Title: Function to compute estimates
> ### Aliases: Estimator
> ### Keywords: univar
> 
> ### ** Examples
> 
> x <- rnorm(100)
> Estimator(x, estimator = mean, name = "mean")
Evaluations of mean:
--------------------
An object of class "Estimate" 
generated by call
  Estimator(x = x, estimator = mean, name = "mean")
samplesize:   100
estimate:
    mean1 
0.1088874 
> 
> X <- matrix(rnorm(1000), nrow = 10)
> Estimator(X, estimator = rowMeans, name = "mean")
Evaluations of mean:
--------------------
An object of class "Estimate" 
generated by call
  Estimator(x = X, estimator = rowMeans, name = "mean")
samplesize:   100
estimate:
  rowMeans1   rowMeans2   rowMeans3   rowMeans4   rowMeans5   rowMeans6 
-0.10612810  0.22309674 -0.01146361 -0.20224815  0.08660978 -0.13837167 
  rowMeans7   rowMeans8   rowMeans9  rowMeans10 
-0.03214991 -0.02971528 -0.13027892  0.10496336 
> 
> 
> 
> cleanEx()
> nameEx("EvenSymmetric-class")
> ### * EvenSymmetric-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: EvenSymmetric-class
> ### Title: Class for Even Functions
> ### Aliases: EvenSymmetric-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("EvenSymmetric")
type of symmetry:	even function
center of symmetry:
numeric(0)
> 
> 
> 
> cleanEx()
> nameEx("EvenSymmetric")
> ### * EvenSymmetric
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: EvenSymmetric
> ### Title: Generating function for EvenSymmetric-class
> ### Aliases: EvenSymmetric
> ### Keywords: math
> 
> ### ** Examples
> 
> EvenSymmetric()
type of symmetry:	even function
center of symmetry:
[1] 0
> 
> ## The function is currently defined as
> function(SymmCenter = 0){ 
+     new("EvenSymmetric", SymmCenter = SymmCenter) 
+ }
function (SymmCenter = 0) 
{
    new("EvenSymmetric", SymmCenter = SymmCenter)
}
> 
> 
> 
> cleanEx()
> nameEx("ExpScaleFamily")
> ### * ExpScaleFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ExpScaleFamily
> ### Title: Generating function for exponential scale families
> ### Aliases: ExpScaleFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (E1 <- ExpScaleFamily())
An object of class "ExpScaleFamily"
### name:	Exponential scale family

### distribution:	Distribution Object of Class: Exp
 rate: 1
Warning in show(x) :
  arithmetics on distributions are understood as operations on r.v.'s
see 'distrARITH()'; for switching off this warning see '?distroptions'

### param:	An object of class "ParamWithScaleFamParameter"
name:	scale
scale:	1
trafo:
      scale
scale     1

### props:
[1] "The Exponential scale family is invariant under"
[2] "the group of transformations 'g(y) = scale*y'"  
[3] "with scale parameter 'scale'"                   
> plot(E1)
> Map(L2deriv(E1)[[1]])
[[1]]
function (x) 
{
    y <- 0 * x
    inS <- liesInSupport(distr.0, x, checkFin = TRUE)
    y[inS] <- ((x[inS] - 0)/scale * LogDeriv((x[inS] - 0)/c(scale = 1)) - 
        1)/c(scale = 1)
    return(y)
}
<environment: 0x0c16b990>

> ## IGNORE_RDIFF_BEGIN
> checkL2deriv(E1)
precision of centering:	 -2.042661e-06 
precision of Fisher information:
            scale
scale -3.5986e-05
precision of Fisher information - relativ error [%]:
     [,1]    
[1,] -3.6e-03
condition of Fisher information:
[1] 1
> ## IGNORE_RDIFF_END
> 
> 
> 
> cleanEx()
> nameEx("FunSymmList-class")
> ### * FunSymmList-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: FunSymmList-class
> ### Title: List of Symmetries for a List of Functions
> ### Aliases: FunSymmList-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("FunSymmList", list(NonSymmetric(), EvenSymmetric(SymmCenter = 1), 
+                         OddSymmetric(SymmCenter = 2)))
An object of class "FunSymmList"
[[1]]
type of symmetry:	non-symmetric function
NULL

[[2]]
type of symmetry:	even function
center of symmetry:
[1] 1

[[3]]
type of symmetry:	odd function
center of symmetry:
[1] 2

> 
> 
> 
> cleanEx()
> nameEx("FunSymmList")
> ### * FunSymmList
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: FunSymmList
> ### Title: Generating function for FunSymmList-class
> ### Aliases: FunSymmList
> ### Keywords: math
> 
> ### ** Examples
> 
> FunSymmList(NonSymmetric(), EvenSymmetric(SymmCenter = 1), 
+             OddSymmetric(SymmCenter = 2))
An object of class "FunSymmList"
[[1]]
type of symmetry:	non-symmetric function
NULL

[[2]]
type of symmetry:	even function
center of symmetry:
[1] 1

[[3]]
type of symmetry:	odd function
center of symmetry:
[1] 2

> 
> ## The function is currently defined as
> function (...){
+     new("FunSymmList", list(...))
+ }
function (...) 
{
    new("FunSymmList", list(...))
}
> 
> 
> 
> cleanEx()
> nameEx("GammaFamily")
> ### * GammaFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: GammaFamily
> ### Title: Generating function for Gamma families
> ### Aliases: GammaFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (G1 <- GammaFamily())
An object of class "GammaFamily"
### name:	Gamma family

### distribution:	Distribution Object of Class: Gammad
 shape: 1
 scale: 1

### param:	An object of class "ParamWithScaleAndShapeFamParameter"
name:	scale and shape
scale:	1
shape:	1
trafo:
      scale shape
scale     1     0
shape     0     1
Shape parameter must not be negative.

### props:
[1] "The Gamma family is scale invariant via the parametrization"
[2] "'(nu,shape)=(log(scale),shape)'"                            
> FisherInfo(G1)
An object of class "PosDefSymmMatrix"
      scale    shape
scale     1 1.000000
shape     1 1.644934
> ## IGNORE_RDIFF_BEGIN
> checkL2deriv(G1)
precision of centering:	 -2.042661e-06 1.791171e-06 
precision of Fisher information:
            scale       shape
scale -3.5986e-05 -9.5036e-06
shape -9.5036e-06 -3.9444e-05
precision of Fisher information - relativ error [%]:
     [,1]     [,2]    
[1,] -3.6e-03 -9.5e-04
[2,] -9.5e-04 -2.4e-03
condition of Fisher information:
[1] 10.603
> ## IGNORE_RDIFF_END
> 
> 
> 
> cleanEx()
> nameEx("InfoNorm")
> ### * InfoNorm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: InfoNorm
> ### Title: Generating function for InfoNorm-class
> ### Aliases: InfoNorm
> ### Keywords: robust
> 
> ### ** Examples
> 
> ## IGNORE_RDIFF_BEGIN
> InfoNorm()
An object of class "InfoNorm"
Slot "QuadForm":
An object of class "PosSemDefSymmMatrix"
     [,1]
[1,]    1

Slot "name":
[1] "Information matrix Norm"

Slot "fct":
function(x) QuadFormNorm(x, A = A)
<bytecode: 0x0d604ac8>
<environment: 0x0d6068a8>

> 
> ## The function is currently defined as
> function(){ new("InfoNorm") }
function () 
{
    new("InfoNorm")
}
> ## IGNORE_RDIFF_END
> 
> 
> 
> cleanEx()
> nameEx("L2GroupFamily-class")
> ### * L2GroupFamily-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2GroupParamFamily-class
> ### Title: L2 differentiable parametric group family
> ### Aliases: L2GroupParamFamily-class LogDeriv
> ###   LogDeriv,L2GroupParamFamily-method LogDeriv<-
> ###   LogDeriv<-,L2GroupParamFamily-method
> ### Keywords: classes models
> 
> ### ** Examples
> 
> F1 <- new("L2GroupParamFamily")
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("L2LocationFamily-class")
> ### * L2LocationFamily-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2LocationFamily-class
> ### Title: L2 differentiable parametric group family
> ### Aliases: L2LocationFamily-class
> ### Keywords: classes models
> 
> ### ** Examples
> 
> F1 <- new("L2LocationFamily")
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("L2LocationFamily")
> ### * L2LocationFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2LocationFamily
> ### Title: Generating function for L2LocationFamily-class
> ### Aliases: L2LocationFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> F1 <- L2LocationFamily()
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("L2LocationScaleFamily-class")
> ### * L2LocationScaleFamily-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2LocationScaleFamily-class
> ### Title: L2 differentiable parametric group family
> ### Aliases: L2LocationScaleFamily-class
> ### Keywords: classes models
> 
> ### ** Examples
> 
> F1 <- new("L2LocationScaleFamily")
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("L2LocationScaleFamily")
> ### * L2LocationScaleFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2LocationScaleFamily
> ### Title: Generating function for L2LocationScaleFamily-class
> ### Aliases: L2LocationScaleFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> F1 <- L2LocationScaleFamily()
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("L2LocationUnknownScaleFamily")
> ### * L2LocationUnknownScaleFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2LocationUnknownScaleFamily
> ### Title: Generating function for L2LocationScaleFamily-class in nuisance
> ###   situation
> ### Aliases: L2LocationUnknownScaleFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> F1 <- L2LocationUnknownScaleFamily()
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("L2ParamFamily-class")
> ### * L2ParamFamily-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2ParamFamily-class
> ### Title: L2 differentiable parametric family
> ### Aliases: plot plot-methods L2ParamFamily-class FisherInfo
> ###   FisherInfo,L2ParamFamily,missing-method
> ###   FisherInfo,L2ParamFamily,ParamFamParameter-method L2deriv
> ###   L2deriv,L2ParamFamily,missing-method
> ###   L2deriv,L2ParamFamily,ParamFamParameter-method L2derivSymm
> ###   L2derivSymm,L2ParamFamily-method L2derivDistr
> ###   L2derivDistr,L2ParamFamily-method L2derivDistrSymm
> ###   L2derivDistrSymm,L2ParamFamily-method
> ###   checkL2deriv,L2ParamFamily-method
> ###   E,L2ParamFamily,EuclRandVariable,missing-method
> ###   E,L2ParamFamily,EuclRandMatrix,missing-method
> ###   E,L2ParamFamily,EuclRandVarList,missing-method
> ###   plot,L2ParamFamily,missing-method
> ### Keywords: classes models
> 
> ### ** Examples
> 
> F1 <- new("L2ParamFamily")
> plot(F1)
> 
> ## selection of subpanels for plotting
> F2 <- L2LocationScaleFamily()
> layout(matrix(c(1,2,3,3), nrow=2, byrow=TRUE))
> plot(F2,mfColRow = FALSE,
+      to.draw.arg=c("p","q","loc"))
> plot(F2,mfColRow = FALSE, inner=list("empirical cdf","pseudo-inverse",
+      "L2-deriv, loc.part"), to.draw.arg=c("p","q","loc"))
> 
> 
> 
> cleanEx()
> nameEx("L2ParamFamily")
> ### * L2ParamFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2ParamFamily
> ### Title: Generating function for L2ParamFamily-class
> ### Aliases: L2ParamFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> F1 <- L2ParamFamily()
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("L2ScaleFamily-class")
> ### * L2ScaleFamily-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2ScaleFamily-class
> ### Title: L2 differentiable parametric group family
> ### Aliases: L2ScaleFamily-class
> ### Keywords: classes models
> 
> ### ** Examples
> 
> F1 <- new("L2ScaleFamily")
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("L2ScaleFamily")
> ### * L2ScaleFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2ScaleFamily
> ### Title: Generating function for L2ScaleFamily-class
> ### Aliases: L2ScaleFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> F1 <- L2ScaleFamily()
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("L2ScaleUnknownLocationFamily")
> ### * L2ScaleUnknownLocationFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: L2ScaleUnknownLocationFamily
> ### Title: Generating function for L2LocationScaleFamily-class in nuisance
> ###   situation
> ### Aliases: L2ScaleUnknownLocationFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> F1 <- L2ScaleUnknownLocationFamily()
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("LnormScaleFamily")
> ### * LnormScaleFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LnormScaleFamily
> ### Title: Generating function for lognormal scale families
> ### Aliases: LnormScaleFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (L1 <- LnormScaleFamily())
An object of class "LnormScaleFamily"
### name:	lognormal scale family

### distribution:	Distribution Object of Class: Lnorm
 meanlog: 0
 sdlog: 1
Warning in show(x) :
  arithmetics on distributions are understood as operations on r.v.'s
see 'distrARITH()'; for switching off this warning see '?distroptions'

### param:	An object of class "ParamWithScaleFamParameter"
name:	scale
meanlog:	1
fixed part of param.:
	:	0
trafo:
      scale
scale     1

### props:
[1] "The lognormal scale family is invariant under"
[2] "the group of transformations 'g(y) = scale*y'"
[3] "with scale parameter 'scale'"                 
> plot(L1)
> Map(L2deriv(L1)[[1]])
[[1]]
function (x) 
{
    y <- 0 * x
    inS <- liesInSupport(distr.0, x, checkFin = TRUE)
    y[inS] <- ((x[inS] - 0)/scale * LogDeriv((x[inS] - 0)/c(meanlog = 1)) - 
        1)/c(meanlog = 1)
    return(y)
}
<environment: 0x11315a18>

> checkL2deriv(L1)
precision of centering:	 -0.003003394 
precision of Fisher information:
          meanlog
meanlog -0.010279
precision of Fisher information - relativ error [%]:
     [,1]  
[1,] -1.028
condition of Fisher information:
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("LogisticLocationScaleFamily")
> ### * LogisticLocationScaleFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: LogisticLocationScaleFamily
> ### Title: Generating function for Logistic location and scale families
> ### Aliases: LogisticLocationScaleFamily LOGISTINT2
> ### Keywords: models
> 
> ### ** Examples
> 
> (L1 <- LogisticLocationScaleFamily())
An object of class "LogisticLocationScaleFamily"
### name:	normal location and scale family

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1
Warning in show(x) :
  arithmetics on distributions are understood as operations on r.v.'s
see 'distrARITH()'; for switching off this warning see '?distroptions'

### param:	An object of class "ParamWithScaleFamParameter"
name:	location and scale
location:	0
scale:	1
trafo:
         location scale
location        1     0
scale           0     1

### props:
[1] "The normal location and scale family is invariant under"  
[2] "the group of transformations 'g(x) = scale*x + loc'"      
[3] "with location parameter 'loc' and scale parameter 'scale'"
> plot(L1)
> FisherInfo(L1)
An object of class "PosDefSymmMatrix"
          location    scale
location 0.3333333 0.000000
scale    0.0000000 1.429956
> ### need smaller integration range:
> distrExoptions("ElowerTruncQuantile"=1e-4,"EupperTruncQuantile"=1e-4)
> checkL2deriv(L1)
precision of centering:	 0 -0.5873198 
precision of Fisher information:
         location    scale
location    -0.16  0.00000
scale        0.00 -0.83493
precision of Fisher information - relativ error [%]:
     [,1]    [,2]   
[1,] -48.001 .      
[2,] .       -58.388
condition of Fisher information:
[1] 3.6679
> distrExoptions("ElowerTruncQuantile"=1e-7,"EupperTruncQuantile"=1e-7)
> ##
> set.seed(123)
> x <- rlogis(100,location=1,scale=2)
> CvMMDEstimator(x, L1)
Evaluations of Minimum CvM distance estimate ( mu = model distr. ) :
--------------------------------------------------------------------
An object of class "CvMMDEstimate" 
generated by call
  CvMMDEstimator(x = x, ParamFamily = L1)
samplesize:   100
estimate:
   location      scale  
  0.9691129   1.9522622 
 (0.4035840) (0.1868609)
asymptotic (co)variance (multiplied with samplesize):
              location         scale
location  1.628800e+01 -3.750942e-06
scale    -3.750942e-06  3.491701e+00
Criterion:
CvM distance 
  0.01469024 
> 
> 
> 
> cleanEx()
> nameEx("MCEstimate-class")
> ### * MCEstimate-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCEstimate-class
> ### Title: MCEstimate-class.
> ### Aliases: MCEstimate-class MDEstimate-class MLEstimate-class
> ###   CvMMDEstimate-class criterion criterion,MCEstimate-method
> ###   criterion.fct criterion.fct,MCEstimate-method
> ###   startPar,MCEstimate-method method method,MCEstimate-method optimwarn
> ###   optimwarn,MCEstimate-method optimReturn optimReturn,MCEstimate-method
> ###   criterion<- criterion<-,MCEstimate-method
> ###   coerce,MCEstimate,mle-method show,MCEstimate-method
> ###   profile,MCEstimate-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## (empirical) Data
> x <- rgamma(50, scale = 0.5, shape = 3)
> 
> ## parametric family of probability measures
> G <- GammaFamily(scale = 1, shape = 2)
> 
> MDEstimator(x, G)
Evaluations of Minimum Kolmogorov distance estimate  :
------------------------------------------------------
An object of class "MDEstimate" 
generated by call
  MDEstimator(x = x, ParamFamily = G)
samplesize:   50
estimate:
    scale     shape 
0.3398645 4.2654569 
Criterion:
Kolmogorov distance 
         0.06350364 
> (m <- MLEstimator(x, G))
Evaluations of Maximum likelihood estimate:
-------------------------------------------
An object of class "MLEstimate" 
generated by call
  MLEstimator(x = x, ParamFamily = G)
samplesize:   50
estimate:
     scale        shape   
  0.34200800   4.06028564 
 (0.07002713) (0.78099026)
asymptotic (co)variance (multiplied with samplesize):
           scale     shape
scale  0.2451899 -2.568863
shape -2.5688629 30.497289
Criterion:
negative log-likelihood 
                47.9651 
> m.mle <- as(m,"mle")
> par(mfrow=c(1,2))
> profileM <- profile(m)
> ## plot-profile throws an error
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("MCEstimator")
> ### * MCEstimator
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCEstimator
> ### Title: Function to compute minimum criterion estimates
> ### Aliases: MCEstimator
> ### Keywords: univar
> 
> ### ** Examples
> 
> ## (empirical) Data
> x <- rgamma(50, scale = 0.5, shape = 3)
> 
> ## parametric family of probability measures
> G <- GammaFamily(scale = 1, shape = 2)
> 
> ## Maximum Likelihood estimator
> ## Note: you can directly use function MLEstimator!
> negLoglikelihood <- function(x, Distribution){
+     res <- -sum(log(Distribution@d(x)))
+     names(res) <- "Negative Log-Likelihood"
+     return(res)
+ }
> MCEstimator(x = x, ParamFamily = G, criterion = negLoglikelihood)
Evaluations of Minimum criterion estimate:
------------------------------------------
An object of class "MCEstimate" 
generated by call
  MCEstimator(x = x, ParamFamily = G, criterion = negLoglikelihood)
samplesize:   50
estimate:
   scale    shape 
0.342008 4.060286 
Criterion:
        
47.9651 
> 
> ## Kolmogorov(-Smirnov) minimum distance estimator
> ## Note: you can also use function MDEstimator!
> MCEstimator(x = x, ParamFamily = G, criterion = KolmogorovDist, 
+             crit.name = "Kolmogorov distance")
Warning in fn(par, ...) :
  Criterion evaluation at theta = 0.298,4.655 threw an error;
returning starting par;

Warning in fn(par, ...) :
  Criterion evaluation at theta = 0.764,4.655 threw an error;
returning starting par;

Warning in fn(par, ...) :
  Criterion evaluation at theta = 0.298,5.12 threw an error;
returning starting par;

Evaluations of Minimum Kolmogorov distance estimate:
----------------------------------------------------
An object of class "MCEstimate" 
generated by call
  MCEstimator(x = x, ParamFamily = G, criterion = KolmogorovDist, 
    crit.name = "Kolmogorov distance")
samplesize:   50
estimate:
    scale     shape 
0.2983286 4.6547001 
Criterion:
Kolmogorov distance 
              1e+20 
> 
> ## Total variation minimum distance estimator
> ## Note: you can also use function MDEstimator!
> ## discretize Gamma distribution
> 
> ## IGNORE_RDIFF_BEGIN
> MCEstimator(x = x, ParamFamily = G, criterion = TotalVarDist,
+             crit.name = "Total variation distance")
Evaluations of Minimum Total variation distance estimate:
---------------------------------------------------------
An object of class "MCEstimate" 
generated by call
  MCEstimator(x = x, ParamFamily = G, criterion = TotalVarDist, 
    crit.name = "Total variation distance")
samplesize:   50
estimate:
    scale     shape 
0.2829687 5.0197306 
Criterion:
Total variation distance 
               0.4866141 
> ## IGNORE_RDIFF_END
> 
> ## or smooth empirical distribution (takes some time!)
> #MCEstimator(x = x, ParamFamily = G, criterion = TotalVarDist, 
> #            asis.smooth.discretize = "smooth", crit.name = "Total variation distance")
> 
> ## Hellinger minimum distance estimator
> ## Note: you can also use function MDEstimator!
> ## discretize Gamma distribution
> distroptions(DistrResolution = 1e-8)
> MCEstimator(x = x, ParamFamily = G, criterion = HellingerDist, 
+             crit.name = "Hellinger Distance", startPar = c(1,2))
Evaluations of Minimum Hellinger Distance estimate:
---------------------------------------------------
An object of class "MCEstimate" 
generated by call
  MCEstimator(x = x, ParamFamily = G, criterion = HellingerDist, 
    crit.name = "Hellinger Distance", startPar = c(1, 2))
samplesize:   50
estimate:
   scale    shape 
1.057442 1.683644 
Criterion:
Hellinger Distance 
         0.3782642 
> distroptions(DistrResolution = 1e-6)
> 
> ## or smooth empirical distribution (takes some time!)
> #MCEstimator(x = x, ParamFamily = G, criterion = HellingerDist, 
> #            asis.smooth.discretize = "smooth", crit.name = "Hellinger distance")
> 
> 
> 
> cleanEx()
> nameEx("MDEstimator")
> ### * MDEstimator
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MDEstimator
> ### Title: Function to compute minimum distance estimates
> ### Aliases: MDEstimator CvMMDEstimator KolmogorovMDEstimator
> ###   TotalVarMDEstimator HellingerMDEstimator CvMDist2
> ### Keywords: univar robust
> 
> ### ** Examples
> 
> ## (empirical) Data
> set.seed(123)
> x <- rgamma(50, scale = 0.5, shape = 3)
> 
> ## parametric family of probability measures
> G <- GammaFamily(scale = 1, shape = 2)
> 
> ## Kolmogorov(-Smirnov) minimum distance estimator
> MDEstimator(x = x, ParamFamily = G, distance = KolmogorovDist)
Evaluations of Minimum Kolmogorov distance estimate  :
------------------------------------------------------
An object of class "MDEstimate" 
generated by call
  MDEstimator(x = x, ParamFamily = G, distance = KolmogorovDist)
samplesize:   50
estimate:
    scale     shape 
0.5325299 2.4106229 
Criterion:
Kolmogorov distance 
         0.07111522 
> ## or
> KolmogorovMDEstimator(x = x, ParamFamily = G)
Evaluations of Minimum Kolmogorov distance estimate  :
------------------------------------------------------
An object of class "MDEstimate" 
generated by call
  KolmogorovMDEstimator(x = x, ParamFamily = G)
samplesize:   50
estimate:
    scale     shape 
0.5325299 2.4106229 
Criterion:
Kolmogorov distance 
         0.07111522 
> 
> ## von Mises minimum distance estimator with default mu = Mod
> MDEstimator(x = x, ParamFamily = G, distance = CvMDist)
Evaluations of Minimum CvM distance estimate ( mu = emp. cdf )  :
-----------------------------------------------------------------
An object of class "CvMMDEstimate" 
generated by call
  MDEstimator(x = x, ParamFamily = G, distance = CvMDist)
samplesize:   50
estimate:
    scale     shape 
0.4683173 2.6527970 
Criterion:
CvM distance 
  0.03266119 
> 
> 
> 
> 
> cleanEx()
> nameEx("MLEstimator")
> ### * MLEstimator
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MLEstimator
> ### Title: Function to compute maximum likelihood estimates
> ### Aliases: MLEstimator
> ### Keywords: univar
> 
> ### ** Examples
> 
> #############################
> ## 1. Binomial data
> #############################
> ## (empirical) data
> # seed for reproducibility:
> set.seed(20200306)
> x <- rbinom(100, size=25, prob=.25)
> 
> ## ML-estimate
> MLEstimator(x, BinomFamily(size = 25))
Evaluations of Maximum likelihood estimate:
-------------------------------------------
An object of class "MLEstimate" 
generated by call
  MLEstimator(x = x, ParamFamily = BinomFamily(size = 25))
samplesize:   100
estimate:
              
  0.246000000 
 (0.008613571)
fixed part of the parameter:
size 
  25 
asymptotic (co)variance (multiplied with samplesize):
[1] 0.00741936
Criterion:
negative log-likelihood 
               220.6748 
> 
> 
> #############################
> ## 2. Poisson data
> #############################
> ## Example: Rutherford-Geiger (1910); cf. Feller~(1968), Section VI.7 (a)
> x <- c(rep(0, 57), rep(1, 203), rep(2, 383), rep(3, 525), rep(4, 532), 
+        rep(5, 408), rep(6, 273), rep(7, 139), rep(8, 45), rep(9, 27), 
+        rep(10, 10), rep(11, 4), rep(12, 0), rep(13, 1), rep(14, 1))
> 
> ## ML-estimate
> MLEstimator(x, PoisFamily())
Evaluations of Maximum likelihood estimate:
-------------------------------------------
An object of class "MLEstimate" 
generated by call
  MLEstimator(x = x, ParamFamily = PoisFamily())
samplesize:   2608
estimate:
             
  3.87154908 
 (0.03852908)
asymptotic (co)variance (multiplied with samplesize):
[1] 3.871549
Criterion:
negative log-likelihood 
               5352.105 
> 
> 
> #############################
> ## 3. Normal (Gaussian) location and scale
> #############################
> ## (empirical) data
> # seed for reproducibility:
> set.seed(20200306)
> x <- rnorm(100)
> 
> ## ML-estimate
> MLEstimator(x, NormLocationScaleFamily())
Evaluations of Maximum likelihood estimate:
-------------------------------------------
An object of class "MLEstimate" 
generated by call
  MLEstimator(x = x, ParamFamily = NormLocationScaleFamily())
samplesize:   100
estimate:
      mean           sd     
  -0.03255591    1.02007192 
 ( 0.10200719) ( 0.07212998)
asymptotic (co)variance (multiplied with samplesize):
         mean        sd
mean 1.040547 0.0000000
sd   0.000000 0.5202734
Criterion:
negative log-likelihood 
               143.8812 
> ## compare:
> c(mean(x),sd(x))
[1] -0.03255591  1.02521086
> 
> 
> #############################
> ## 4. Gamma model
> #############################
> ## (empirical) data
> # seed for reproducibility:
> set.seed(20200306)
> x <- rgamma(50, scale = 0.5, shape = 3)
> 
> ## parametric family of probability measures
> G <- GammaFamily(scale = 1, shape = 2)
> 
> ## Maximum likelihood estimator
> (res <- MLEstimator(x = x, ParamFamily = G))
Evaluations of Maximum likelihood estimate:
-------------------------------------------
An object of class "MLEstimate" 
generated by call
  MLEstimator(x = x, ParamFamily = G)
samplesize:   50
estimate:
     scale       shape  
  0.4421995   3.5180238 
 (0.0909164) (0.6729136)
asymptotic (co)variance (multiplied with samplesize):
           scale     shape
scale  0.4132896 -2.845824
shape -2.8458244 22.640637
Criterion:
negative log-likelihood 
               56.51362 
> 
> ## Asymptotic (CLT-based) confidence interval
> confint(res)
A[n] asymptotic (CLT-based) confidence interval:
          2.5 %    97.5 %
scale 0.2640066 0.6203924
shape 2.1991373 4.8369102
Type of estimator: Maximum likelihood estimate
samplesize:   50
Call by which estimate was produced:
MLEstimator(x = x, ParamFamily = G)
> 
> ## some profiling
> par(mfrow=c(1,2))
> plot(profile(res))
> par(mfrow=c(1,1))
> 
> ## implementation of ML-estimator of package MASS
> require(MASS)
> (res1 <- fitdistr(x, "gamma"))
Warning in densfun(x, parm[1], parm[2], ...) : NaNs produced
     shape       rate   
  3.5180020   2.2612888 
 (0.6729072) (0.4649203)
> 
> ## comparison
> ## shape
> estimate(res)[2]
   shape 
3.518024 
> ## rate
> 1/estimate(res)[1]
   scale 
2.261423 
> 
> ## minor differences due to the fact that by default, fitdistr uses
> ## BFGS, while we use Nelder-Mead instead
> 
> ## log-likelihood
> res1$loglik
[1] -56.51362
> ## negative log-likelihood
> criterion(res)
negative log-likelihood 
               56.51362 
> 
> 
> ## explicitely transforming to
> ## MASS parametrization:
> mtrafo <- function(x){
+      nms0 <- names(c(main(param(G)),nuisance(param(G))))
+      nms <- c("shape","rate")
+      fval0 <- c(x[2], 1/x[1])
+      names(fval0) <- nms
+      mat0 <- matrix( c(0, -1/x[1]^2, 1, 0), nrow = 2, ncol = 2,
+                      dimnames = list(nms,nms0))                          
+      list(fval = fval0, mat = mat0)}
> 
> G2 <- G
> trafo(G2) <- mtrafo
> res2 <- MLEstimator(x = x, ParamFamily = G2)
> 
> old <- getdistrModOption("show.details")
> distrModoptions("show.details" = "minimal")
> res1
     shape       rate   
  3.5180020   2.2612888 
 (0.6729072) (0.4649203)
> res2
Evaluations of Maximum likelihood estimate:
-------------------------------------------
     shape       rate   
  3.5180238   2.2614228 
 (0.6729136) (0.4649495)
> 
> ## some profiling
> par(mfrow=c(1,2))
> plot(profile(res2))
> par(mfrow=c(1,1))
> 
> #############################
> ## 5. Cauchy Location Scale model
> #############################
> (C <- CauchyLocationScaleFamily())
An object of class "CauchyLocationScaleFamily"
### name:	Cauchy Location and scale family

### distribution:	Distribution Object of Class: Cauchy
 location: 0
 scale: 1

### param:	An object of class "ParamWithScaleFamParameter"
name:	location and scale
loc:	0
scale:	1

### props:
[1] "The Cauchy Location and scale family is invariant under"  
[2] "the group of transformations 'g(x) = scale*x + loc'"      
[3] "with location parameter 'loc' and scale parameter 'scale'"
> loc.true <- 1
> scl.true <- 2
> 
> ## (empirical) data
> # seed for reproducibility:
> set.seed(20200306)
> x <- rcauchy(50, location = loc.true, scale = scl.true)
> 
> ## Maximum likelihood estimator
> (res <- MLEstimator(x = x, ParamFamily = C))
Evaluations of Maximum likelihood estimate:
-------------------------------------------
      loc        scale  
  1.0723789   1.9896397 
 (0.3979279) (0.3979279)
> ## Asymptotic (CLT-based) confidence interval
> confint(res)
A[n] asymptotic (CLT-based) confidence interval:
          2.5 %   97.5 %
loc   0.2924544 1.852303
scale 1.2097153 2.769564
> 
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("NBinomFamily")
> ### * NBinomFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NbinomFamily
> ### Title: Generating function for Nbinomial families
> ### Aliases: NbinomFamily NbinomwithSizeFamily NbinomMeanSizeFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (N1 <- NbinomFamily(size = 25, prob = 0.25))
An object of class "NbinomFamily"
### name:	Negative Binomial family

### distribution:	Distribution Object of Class: Nbinom
 size: 25
 prob: 0.25

### param:	An object of class "ParamFamParameter"
name:	probability of success
prob:	0.25
fixed part of param.:
	size:	25

### props:
[1] ""
> plot(N1)
> FisherInfo(N1)
An object of class "PosSemDefSymmMatrix"
         prob
prob 533.3333
> checkL2deriv(N1)
precision of centering:	 0.001177892 
precision of Fisher information:
         prob
prob -0.16012
precision of Fisher information - relativ error [%]:
     [,1]  
[1,] -3e-02
condition of Fisher information:
[1] 1
> (N1.w <- NbinomwithSizeFamily(size = 25, prob = 0.25))
An object of class "NbinomwithSizeFamily"
### name:	Negative Binomial family

### distribution:	Distribution Object of Class: Nbinom
 size: 25
 prob: 0.25

### param:	An object of class "ParamFamParameter"
name:	NegBinomParameter
size:	25
prob:	0.25

### props:
[1] ""
> plot(N1.w)
> FisherInfo(N1.w)
An object of class "PosSemDefSymmMatrix"
            size     prob
size  0.03044974  -4.0000
prob -4.00000000 533.3333
> checkL2deriv(N1.w)
precision of centering:	 -6.24598e-06 0.001177892 
precision of Fisher information:
            size        prob
size -4.4628e-06  8.4814e-04
prob  8.4814e-04 -1.6012e-01
precision of Fisher information - relativ error [%]:
     [,1]    [,2]   
[1,] -0.0147 -0.0212
[2,] -0.0212 -0.0300
condition of Fisher information:
[1] 1194827
> (N2.w <- NbinomMeanSizeFamily(size = 25, mean = 75))
An object of class "NbinomMeanSizeFamily"
### name:	Negative Binomial family

### distribution:	Distribution Object of Class: Nbinom
 size: 25
 prob: 0.25

### param:	An object of class "ParamFamParameter"
name:	probability of success
size:	25
mean:	75

### props:
[1] ""
> plot(N2.w)
> FisherInfo(N2.w)
An object of class "PosSemDefSymmMatrix"
             size         mean
size 3.044974e-02     1600.091
mean 1.600091e+03 85342933.607
> checkL2deriv(N2.w)
precision of centering:	 -6.25e-06 -0.4711755 
precision of Fisher information:
            size        mean
size -4.4600e-06 -3.3927e-01
mean -3.3927e-01 -2.5621e+04
precision of Fisher information - relativ error [%]:
     [,1]    [,2]   
[1,] -0.0147 -0.0212
[2,] -0.0212 -0.0300
condition of Fisher information:
[1] 1.8978e+11
> 
> 
> 
> 
> cleanEx()
> nameEx("NonSymmetric-class")
> ### * NonSymmetric-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NonSymmetric-class
> ### Title: Class for Non-symmetric Functions
> ### Aliases: NonSymmetric-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("NonSymmetric")
type of symmetry:	non-symmetric function
NULL
> 
> 
> 
> cleanEx()
> nameEx("NonSymmetric")
> ### * NonSymmetric
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NonSymmetric
> ### Title: Generating function for NonSymmetric-class
> ### Aliases: NonSymmetric
> ### Keywords: math
> 
> ### ** Examples
> 
> NonSymmetric()
type of symmetry:	non-symmetric function
NULL
> 
> ## The function is currently defined as
> function(){ new("NonSymmetric") }
function () 
{
    new("NonSymmetric")
}
> 
> 
> 
> cleanEx()
> nameEx("NormLocationFamily")
> ### * NormLocationFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NormLocationFamily
> ### Title: Generating function for normal location families
> ### Aliases: NormLocationFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (N1 <- NormLocationFamily())
An object of class "NormLocationFamily"
### name:	normal location family

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1
Warning in show(x) :
  arithmetics on distributions are understood as operations on r.v.'s
see 'distrARITH()'; for switching off this warning see '?distroptions'

### param:	An object of class "ParamFamParameter"
name:	loc
mean:	0

### props:
[1] "The normal location family is invariant under"
[2] "the group of transformations 'g(x) = x + loc'"
[3] "with location parameter 'loc'"                
> plot(N1)
> L2derivDistr(N1)
An object of class "UnivarDistrList"
 [[1]] Distribution Object of Class: Norm
       :mean: 0
       :sd: 1
> 
> 
> 
> cleanEx()
> nameEx("NormLocationScaleFamily")
> ### * NormLocationScaleFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NormLocationScaleFamily
> ### Title: Generating function for normal location and scale families
> ### Aliases: NormLocationScaleFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (N1 <- NormLocationScaleFamily())
An object of class "NormLocationScaleFamily"
### name:	normal location and scale family

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1
Warning in show(x) :
  arithmetics on distributions are understood as operations on r.v.'s
see 'distrARITH()'; for switching off this warning see '?distroptions'

### param:	An object of class "ParamWithScaleFamParameter"
name:	location and scale
mean:	0
sd:	1

### props:
[1] "The normal location and scale family is invariant under"  
[2] "the group of transformations 'g(x) = scale*x + loc'"      
[3] "with location parameter 'loc' and scale parameter 'scale'"
> plot(N1)
> FisherInfo(N1)
An object of class "PosDefSymmMatrix"
     mean sd
mean    1  0
sd      0  2
> checkL2deriv(N1)
precision of centering:	 0 -5.594001e-06 
precision of Fisher information:
           mean          sd
mean -5.794e-06  0.0000e+00
sd    0.000e+00 -1.5722e-04
precision of Fisher information - relativ error [%]:
     [,1]      [,2]     
[1,] -5.79e-04 .        
[2,] .         -7.86e-03
condition of Fisher information:
[1] 1.6667
> 
> 
> 
> cleanEx()
> nameEx("NormLocationUnknownScaleFamily")
> ### * NormLocationUnknownScaleFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NormLocationUnknownScaleFamily
> ### Title: Generating function for normal location families with unknown
> ###   scale as nuisance
> ### Aliases: NormLocationUnknownScaleFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (N1 <- NormLocationUnknownScaleFamily())
An object of class "L2LocationScaleFamily"
### name:	normal location family with unknown scale (as nuisance)

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1
Warning in show(x) :
  arithmetics on distributions are understood as operations on r.v.'s
see 'distrARITH()'; for switching off this warning see '?distroptions'

### param:	An object of class "ParamWithScaleFamParameter"
name:	location and scale
mean:	0
nuisance:
sd:	1

### props:
[1] "The normal location family with unknown scale (as nuisance) is invariant under"
[2] "the group of transformations 'g(x) = scale*x + loc'"                           
[3] "with location parameter 'loc' and scale parameter 'scale'"                     
> plot(N1)
> FisherInfo(N1)
An object of class "PosDefSymmMatrix"
     mean sd
mean    1  0
sd      0  2
> checkL2deriv(N1)
precision of centering:	 0 -5.594001e-06 
precision of Fisher information:
           mean          sd
mean -5.794e-06  0.0000e+00
sd    0.000e+00 -1.5722e-04
precision of Fisher information - relativ error [%]:
     [,1]      [,2]     
[1,] -5.79e-04 .        
[2,] .         -7.86e-03
condition of Fisher information:
[1] 1.6667
> 
> 
> 
> cleanEx()
> nameEx("NormScaleFamily")
> ### * NormScaleFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NormScaleFamily
> ### Title: Generating function for normal scale families
> ### Aliases: NormScaleFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (N1 <- NormScaleFamily())
An object of class "NormScaleFamily"
### name:	normal scale family

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1
Warning in show(x) :
  arithmetics on distributions are understood as operations on r.v.'s
see 'distrARITH()'; for switching off this warning see '?distroptions'

### param:	An object of class "ParamWithScaleFamParameter"
name:	scale
sd:	1
fixed part of param.:
	mean:	0

### props:
[1] "The normal scale family is invariant under"   
[2] "the group of transformations 'g(y) = scale*y'"
[3] "with scale parameter 'scale'"                 
> plot(N1)
> FisherInfo(N1)
An object of class "PosDefSymmMatrix"
   sd
sd  2
> checkL2deriv(N1)
precision of centering:	 -5.594001e-06 
precision of Fisher information:
            sd
sd -1.5722e-04
precision of Fisher information - relativ error [%]:
     [,1]     
[1,] -7.86e-03
condition of Fisher information:
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("NormScaleUnknownLocationFamily")
> ### * NormScaleUnknownLocationFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NormScaleUnknownLocationFamily
> ### Title: Generating function for normal scale families with unknown
> ###   location as nuisance
> ### Aliases: NormScaleUnknownLocationFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (N1 <- NormScaleUnknownLocationFamily())
An object of class "L2LocationScaleFamily"
### name:	normal scale family with unknown location (as nuisance)

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1
Warning in show(x) :
  arithmetics on distributions are understood as operations on r.v.'s
see 'distrARITH()'; for switching off this warning see '?distroptions'

### param:	An object of class "ParamWithScaleFamParameter"
name:	scale and location
sd:	1
nuisance:
mean:	0

### props:
[1] "The normal scale family with unknown location (as nuisance) is invariant under"
[2] "the group of transformations 'g(x) = scale*x + loc'"                           
[3] "with location parameter 'loc' and scale parameter 'scale'"                     
> plot(N1)
> FisherInfo(N1)
An object of class "PosDefSymmMatrix"
     sd mean
sd    1    0
mean  0    2
> checkL2deriv(N1)
precision of centering:	 0 -5.594001e-06 
precision of Fisher information:
             sd        mean
sd   -5.794e-06  0.0000e+00
mean  0.000e+00 -1.5722e-04
precision of Fisher information - relativ error [%]:
     [,1]      [,2]     
[1,] -5.79e-04 .        
[2,] .         -7.86e-03
condition of Fisher information:
[1] 1.6667
> 
> 
> 
> cleanEx()
> nameEx("NormType-class")
> ### * NormType-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NormType-class
> ### Title: Norm Type
> ### Aliases: NormType-class name,NormType-method name<-,NormType-method fct
> ###   fct<- fct,NormType-method fct<-,NormType-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> ## IGNORE_RDIFF_BEGIN
> EuclNorm <- NormType("EuclideanNorm",EuclideanNorm)
> fct(EuclNorm)
function(x){ 
    if(is.vector(x)) 
        return(abs(x))
    else 
        return(sqrt(colSums(x^2)))
}
<bytecode: 0x11d86f90>
<environment: namespace:distrMod>
> name(EuclNorm)
[1] "EuclideanNorm"
> ## IGNORE_RDIFF_END
> 
> 
> 
> cleanEx()
> nameEx("NormType")
> ### * NormType
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: NormType
> ### Title: Generating function for NormType-class
> ### Aliases: NormType
> ### Keywords: math
> 
> ### ** Examples
> 
> ## IGNORE_RDIFF_BEGIN
> NormType()
An object of class "NormType"
Slot "name":
[1] "EuclideanNorm"

Slot "fct":
function(x){ 
    if(is.vector(x)) 
        return(abs(x))
    else 
        return(sqrt(colSums(x^2)))
}
<bytecode: 0x11d86f90>
<environment: namespace:distrMod>

> ## IGNORE_RDIFF_END
> 
> 
> 
> cleanEx()
> nameEx("OddSymmetric-class")
> ### * OddSymmetric-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: OddSymmetric-class
> ### Title: Class for Odd Functions
> ### Aliases: OddSymmetric-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("OddSymmetric")
type of symmetry:	odd function
center of symmetry:
numeric(0)
> 
> 
> 
> cleanEx()
> nameEx("OddSymmetric")
> ### * OddSymmetric
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: OddSymmetric
> ### Title: Generating function for OddSymmetric-class
> ### Aliases: OddSymmetric
> ### Keywords: math
> 
> ### ** Examples
> 
> OddSymmetric()
type of symmetry:	odd function
center of symmetry:
[1] 0
> 
> ## The function is currently defined as
> function(SymmCenter = 0){ 
+     new("OddSymmetric", SymmCenter = SymmCenter) 
+ }
function (SymmCenter = 0) 
{
    new("OddSymmetric", SymmCenter = SymmCenter)
}
> 
> 
> 
> cleanEx()
> nameEx("ParamFamParameter-class")
> ### * ParamFamParameter-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ParamFamParameter-class
> ### Title: Parameter of a parametric family of probability measures
> ### Aliases: ParamFamParameter-class ParamWithScaleFamParameter-class
> ###   ParamWithScaleAndShapeFamParameter-class
> ###   ParamWithShapeFamParameter-class length,ParamFamParameter-method
> ###   dimension,ParamFamParameter-method main main,ParamFamParameter-method
> ###   main,ParamWithScaleAndShapeFamParameter-method main<-
> ###   main<-,ParamFamParameter-method nuisance
> ###   nuisance,ParamFamParameter-method
> ###   nuisance,ParamWithScaleAndShapeFamParameter-method nuisance<-
> ###   nuisance<-,ParamFamParameter-method fixed
> ###   fixed,ParamFamParameter-method
> ###   fixed,ParamWithScaleAndShapeFamParameter-method fixed<-
> ###   fixed<-,ParamFamParameter-method withPosRestr
> ###   withPosRestr,ParamWithShapeFamParameter-method withPosRestr<-
> ###   withPosRestr<-,ParamWithShapeFamParameter-method
> ###   show,ParamFamParameter-method show,ParamWithShapeFamParameter-method
> ###   show,ParamWithScaleAndShapeFamParameter-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("ParamFamParameter")
An object of class "ParamFamParameter"
name:	parameter of a parametric family of probability measures
> 
> 
> 
> cleanEx()
> nameEx("ParamFamParameter")
> ### * ParamFamParameter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ParamFamParameter
> ### Title: Generating function for ParamFamParameter-class
> ### Aliases: ParamFamParameter
> ### Keywords: models
> 
> ### ** Examples
> 
> ParamFamParameter(main = 0, nuisance = 1, fixed = 2,
+                   trafo = function(x) list(fval = sin(x), 
+                                             mat = matrix(cos(x),1,1))
+                   )                          
An object of class "ParamFamParameter"
name:	parameter of a parametric family of probability measures
main:	0
nuisance:	1
fixed part of param.:	2
> 
> 
> 
> 
> cleanEx()
> nameEx("ParamFamily-class")
> ### * ParamFamily-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ParamFamily-class
> ### Title: Parametric family of probability measures.
> ### Aliases: ParamFamily-class main,ParamFamily-method
> ###   nuisance,ParamFamily-method fixed,ParamFamily-method
> ###   param,ParamFamily-method modifyParam modifyParam,ParamFamily-method
> ###   fam.call fam.call,ParamFamily-method startPar
> ###   startPar,ParamFamily-method makeOKPar makeOKPar,ParamFamily-method
> ###   plot,ParamFamily,missing-method show,ParamFamily-method
> ### Keywords: classes models
> 
> ### ** Examples
> 
> F1 <- new("ParamFamily") # prototype
> plot(F1)
> 
> 
> 
> cleanEx()
> nameEx("ParamFamily")
> ### * ParamFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ParamFamily
> ### Title: Generating function for ParamFamily-class
> ### Aliases: ParamFamily
> ### Keywords: distribution models
> 
> ### ** Examples
> 
> 
> ## "default" (normal location)
> F1 <- ParamFamily(modifyParam = function(theta){ Norm(mean = theta) })
> plot(F1)
> 
> ################################
> ## Some examples:
> ################################
> ## 1. Normal location family
> theta <- 0
> names(theta) <- "mean"
> NL <- ParamFamily(name = "Normal location family",
+           param = ParamFamParameter(name = "location parameter", main = theta),
+           distribution = Norm(mean = 0, sd = 1), ## sd known!
+           startPar = function(x,...) c(min(x),max(x)),
+           distrSymm <- SphericalSymmetry(SymmCenter = 0),
+           modifyParam = function(theta){ Norm(mean = theta, sd = 1) },
+           props = paste(c("The normal location family is invariant under",
+                     "the group of transformations 'g(x) = x + mean'",
+                     "with location parameter 'mean'"), collapse = " "))
> NL
An object of class "ParamFamily"
### name:	Normal location family

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1

### param:	An object of class "ParamFamParameter"
name:	location parameter
mean:	0

### props:
[1] "The normal location family is invariant under the group of transformations 'g(x) = x + mean' with location parameter 'mean'"
> 
> ## 2. Normal scale family
> theta <- 1
> names(theta) <- "sd"
> NS <- ParamFamily(name = "Normal scale family",
+           param = ParamFamParameter(name = "scale parameter", main = theta,
+           .returnClsName = "ParamWithScaleFamParameter"),
+           distribution = Norm(mean = 0, sd = 1), ## mean known!
+           startPar = function(x,...) c(0,-min(x)+max(x)),
+           distrSymm <- SphericalSymmetry(SymmCenter = 0),
+           modifyParam = function(theta){ Norm(mean = 0, sd = theta) },
+           props = paste(c("The normal scale family is invariant under",
+                     "the group of transformations 'g(y) = sd*y'",
+                     "with scale parameter 'sd'"), collapse = " "))
> NS
An object of class "ParamFamily"
### name:	Normal scale family

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1

### param:	An object of class "ParamWithScaleFamParameter"
name:	scale parameter
sd:	1

### props:
[1] "The normal scale family is invariant under the group of transformations 'g(y) = sd*y' with scale parameter 'sd'"
> 
> ## 3. Normal location and scale family
> theta <- c(0, 1)
> names(theta) <- c("mean", "sd")
> NLS <- ParamFamily(name = "Normal location and scale family",
+           param = ParamFamParameter(name = "location and scale parameter",
+                                     main = theta,
+                                  .returnClsName = "ParamWithScaleFamParameter"),
+           distribution = Norm(mean = 0, sd = 1),
+           startPar = function(x,...) c(median(x),mad(x)),
+           makeOKPar = function(param) {param[2]<-abs(param[2]); return(param)},
+           distrSymm <- SphericalSymmetry(SymmCenter = 0),
+           modifyParam = function(theta){
+                             Norm(mean = theta[1], sd = theta[2])
+                         },
+           props = paste(c("The normal location and scale family is",
+                     "invariant under the group of transformations",
+                     "'g(x) = sd*x + mean' with location parameter",
+                     "'mean' and scale parameter 'sd'"),
+                     collapse = " "))
> NLS
An object of class "ParamFamily"
### name:	Normal location and scale family

### distribution:	Distribution Object of Class: Norm
 mean: 0
 sd: 1

### param:	An object of class "ParamWithScaleFamParameter"
name:	location and scale parameter
mean:	0
sd:	1

### props:
[1] "The normal location and scale family is invariant under the group of transformations 'g(x) = sd*x + mean' with location parameter 'mean' and scale parameter 'sd'"
> 
> ## 4. Binomial family
> theta <- 0.3
> names(theta) <- "prob"
> B <- ParamFamily(name = "Binomial family",
+          param = ParamFamParameter(name = "probability of success", 
+                                    main = theta),
+          startPar = function(x,...) c(0,1),
+          distribution = Binom(size = 15, prob = 0.3), ## size known!
+          modifyParam = function(theta){ Binom(size = 15, prob = theta) },
+          props = paste(c("The Binomial family is symmetric with respect",
+                    "to prob = 0.5; i.e.,",
+                    "d(Binom(size, prob))(k)=d(Binom(size,1-prob))(size-k)"),
+                    collapse = " "))
> B
An object of class "ParamFamily"
### name:	Binomial family

### distribution:	Distribution Object of Class: Binom
 size: 15
 prob: 0.3

### param:	An object of class "ParamFamParameter"
name:	probability of success
prob:	0.3

### props:
[1] "The Binomial family is symmetric with respect to prob = 0.5; i.e., d(Binom(size, prob))(k)=d(Binom(size,1-prob))(size-k)"
> 
> ## 5. Poisson family
> theta <- 7
> names(theta) <- "lambda"
> P <- ParamFamily(name = "Poisson family",
+           param = ParamFamParameter(name = "positive mean", main = theta),
+           startPar = function(x,...) c(0,max(x)),
+           distribution = Pois(lambda = 7),
+           modifyParam = function(theta){ Pois(lambda = theta) })
> P
An object of class "ParamFamily"
### name:	Poisson family

### distribution:	Distribution Object of Class: Pois
 lambda: 7

### param:	An object of class "ParamFamParameter"
name:	positive mean
lambda:	7
> 
> 
> ## 6. Exponential scale family
> theta <- 2
> names(theta) <- "scale"
> ES <- ParamFamily(name = "Exponential scale family",
+           param = ParamFamParameter(name = "scale parameter", main = theta,
+                            .returnClsName = "ParamWithScaleFamParameter"),
+           startPar = function(x,...) c(0,max(x)-min(x)),
+           distribution = Exp(rate = 1/2),
+           modifyParam = function(theta){ Exp(rate = 1/theta) },
+           props = paste(c("The Exponential scale family is invariant under",
+                     "the group of transformations 'g(y) = scale*y'",
+                     "with scale parameter 'scale = 1/rate'"),
+                     collapse = " " ))
> ES
An object of class "ParamFamily"
### name:	Exponential scale family

### distribution:	Distribution Object of Class: Exp
 rate: 0.5

### param:	An object of class "ParamWithScaleFamParameter"
name:	scale parameter
scale:	2

### props:
[1] "The Exponential scale family is invariant under the group of transformations 'g(y) = scale*y' with scale parameter 'scale = 1/rate'"
> 
> ## 7. Lognormal scale family
> theta <- 2
> names(theta) <- "scale"
> LS <- ParamFamily(name = "Lognormal scale family",
+           param = ParamFamParameter(name = "scale parameter", main = theta,
+                            .returnClsName = "ParamWithScaleFamParameter"),
+           startPar = function(x,...) c(0,max(x)-min(x)),
+           distribution = Lnorm(meanlog = log(2), sdlog = 2),## sdlog known!
+           modifyParam = function(theta){ 
+                             Lnorm(meanlog = log(theta), sdlog = 2) 
+                         },
+           props = paste(c("The Lognormal scale family is invariant under",
+                     "the group of transformations 'g(y) = scale*y'",
+                     "with scale parameter 'scale = exp(meanlog)'"),
+                     collapse = " "))
> LS
An object of class "ParamFamily"
### name:	Lognormal scale family

### distribution:	Distribution Object of Class: Lnorm
 meanlog: 0.693147180559945
 sdlog: 2

### param:	An object of class "ParamWithScaleFamParameter"
name:	scale parameter
scale:	2

### props:
[1] "The Lognormal scale family is invariant under the group of transformations 'g(y) = scale*y' with scale parameter 'scale = exp(meanlog)'"
> 
> ## 8. Gamma family
> theta <- c(1, 2)
> names(theta) <- c("scale", "shape")
> G <- ParamFamily(name = "Gamma family",
+         param = ParamFamParameter(name = "scale and shape", main = theta,
+                            withPosRestr = TRUE,
+                            .returnClsName = "ParamWithScaleAndShapeFamParameter"),
+         startPar = function(x,...) {E <- mean(x); V <- var(X); c(V/E,E^2/V)},
+         makeOKPar = function(param) abs(param),
+         distribution = Gammad(scale = 1, shape = 2),
+         modifyParam = function(theta){ 
+                           Gammad(scale = theta[1], shape = theta[2]) 
+                       },
+         props = paste(c("The Gamma family is scale invariant via the",
+                   "parametrization '(nu,shape)=(log(scale),shape)'"),
+                   collapse = " "))
> G
An object of class "ParamFamily"
### name:	Gamma family

### distribution:	Distribution Object of Class: Gammad
 shape: 2
 scale: 1

### param:	An object of class "ParamWithScaleAndShapeFamParameter"
name:	scale and shape
scale:	1
shape:	2
Shape parameter must not be negative.

### props:
[1] "The Gamma family is scale invariant via the parametrization '(nu,shape)=(log(scale),shape)'"
> 
> 
> 
> cleanEx()
> nameEx("PoisFamily")
> ### * PoisFamily
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PoisFamily
> ### Title: Generating function for Poisson families
> ### Aliases: PoisFamily
> ### Keywords: models
> 
> ### ** Examples
> 
> (P1 <- PoisFamily(lambda = 4.5))
An object of class "PoisFamily"
### name:	Poisson family

### distribution:	Distribution Object of Class: Pois
 lambda: 4.5

### param:	An object of class "ParamFamParameter"
name:	positive mean
lambda:	4.5
> plot(P1)
> FisherInfo(P1)
An object of class "PosSemDefSymmMatrix"
          lambda
lambda 0.2222222
> checkL2deriv(P1)
precision of centering:	 -9.934798e-07 
precision of Fisher information:
            lambda
lambda -3.2684e-06
precision of Fisher information - relativ error [%]:
     [,1]     
[1,] -1.47e-03
condition of Fisher information:
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("QFNorm")
> ### * QFNorm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: QFNorm
> ### Title: Generating function for QFNorm-class
> ### Aliases: QFNorm
> ### Keywords: math
> 
> ### ** Examples
> 
> ## IGNORE_RDIFF_BEGIN
> QFNorm()
An object of class "QFNorm"
Slot "QuadForm":
An object of class "PosSemDefSymmMatrix"
     [,1]
[1,]    1

Slot "name":
[1] "norm based on quadratic form"

Slot "fct":
function(x) QuadFormNorm(x, A= A0)
<bytecode: 0x11329fe8>
<environment: 0x1132aa08>

> 
> ## The function is currently defined as
> function(){ new("QFNorm") }
function () 
{
    new("QFNorm")
}
> ## IGNORE_RDIFF_END
> 
> 
> 
> cleanEx()
> nameEx("SelfNorm")
> ### * SelfNorm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SelfNorm
> ### Title: Generating function for SelfNorm-class
> ### Aliases: SelfNorm
> ### Keywords: robust
> 
> ### ** Examples
> 
> ## IGNORE_RDIFF_BEGIN
> SelfNorm()
An object of class "SelfNorm"
Slot "QuadForm":
An object of class "PosSemDefSymmMatrix"
     [,1]
[1,]    1

Slot "name":
[1] "Information matrix Norm"

Slot "fct":
function(x) QuadFormNorm(x, A = A)
<bytecode: 0x14974540>
<environment: 0x14975140>

> 
> ## The function is currently defined as
> function(){ new("SelfNorm") }
function () 
{
    new("SelfNorm")
}
> ## IGNORE_RDIFF_END
> 
> 
> 
> cleanEx()
> nameEx("addAlphTrsp2col")
> ### * addAlphTrsp2col
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: addAlphTrsp2col
> ### Title: "addAlphTrsp2col"
> ### Aliases: addAlphTrsp2col
> ### Keywords: distribution
> 
> ### ** Examples
> 
> ## IGNORE_RDIFF_BEGIN
>   addAlphTrsp2col(rgb(1,0.3,0.03), 25)
[1] "#FF4D0819"
>   ## gives "#FF4C0819" on 32bit and "#FF4D0819" on 64bit
> ## IGNORE_RDIFF_END
>   addAlphTrsp2col("darkblue", 25)
[1] "#00008B19"
>   addAlphTrsp2col("#AAAAAAAA",25)
[1] "#AAAAAA19"
>   palette(rainbow(6))
>   addAlphTrsp2col(2, 25)
[1] "#FFFF0019"
> 
> 
> 
> cleanEx()
> nameEx("asBias-class")
> ### * asBias-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asBias-class
> ### Title: Standardized Asymptotic Bias
> ### Aliases: asBias-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("asBias")
An object of class "asBias" 
risk type:	 asymptotic bias 
> 
> 
> 
> cleanEx()
> nameEx("asBias")
> ### * asBias
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asBias
> ### Title: Generating function for asBias-class
> ### Aliases: asBias
> ### Keywords: robust
> 
> ### ** Examples
> 
> asBias()
An object of class "asBias" 
risk type:	 asymptotic bias 
> 
> ## The function is currently defined as
> function(biastype = symmetricBias(), normtype = NormType()){ 
+      new("asBias",biastype = biastype, normtype = normtype) }
function (biastype = symmetricBias(), normtype = NormType()) 
{
    new("asBias", biastype = biastype, normtype = normtype)
}
> 
> 
> 
> cleanEx()
> nameEx("asCov-class")
> ### * asCov-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asCov-class
> ### Title: Asymptotic covariance
> ### Aliases: asCov-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("asCov")
An object of class "asCov" 
risk type:	 asymptotic covariance 
> 
> 
> 
> cleanEx()
> nameEx("asCov")
> ### * asCov
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asCov
> ### Title: Generating function for asCov-class
> ### Aliases: asCov
> ### Keywords: robust
> 
> ### ** Examples
> 
> asCov()
An object of class "asCov" 
risk type:	 asymptotic covariance 
> 
> ## The function is currently defined as
> function(){ new("asCov") }
function () 
{
    new("asCov")
}
> 
> 
> 
> cleanEx()
> nameEx("asHampel-class")
> ### * asHampel-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asHampel-class
> ### Title: Asymptotic Hampel risk
> ### Aliases: asHampel-class bound bound,asHampel-method
> ###   show,asHampel-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("asHampel")
An object of class "asHampel" 
risk type:	 trace of asymptotic covariance for given bias bound 
bound:	 Inf 
> 
> 
> 
> cleanEx()
> nameEx("asHampel")
> ### * asHampel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asHampel
> ### Title: Generating function for asHampel-class
> ### Aliases: asHampel
> ### Keywords: robust
> 
> ### ** Examples
> 
> asHampel()
An object of class "asHampel" 
risk type:	 trace of asymptotic covariance for given bias bound 
bound:	 Inf 
> 
> ## The function is currently defined as
> function(bound = Inf, biastype = symmetricBias(), normtype = NormType()){ 
+     new("asHampel", bound = bound, biastype = biastype, normtype = normtype) }
function (bound = Inf, biastype = symmetricBias(), normtype = NormType()) 
{
    new("asHampel", bound = bound, biastype = biastype, normtype = normtype)
}
> 
> 
> 
> cleanEx()
> nameEx("asMSE-class")
> ### * asMSE-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asMSE-class
> ### Title: Asymptotic mean square error
> ### Aliases: asMSE-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("asMSE")
An object of class "asMSE" 
risk type:	 asymptotic mean square error 
> 
> 
> 
> cleanEx()
> nameEx("asMSE")
> ### * asMSE
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asMSE
> ### Title: Generating function for asMSE-class
> ### Aliases: asMSE
> ### Keywords: robust
> 
> ### ** Examples
> 
> asMSE()
An object of class "asMSE" 
risk type:	 asymptotic mean square error 
> 
> ## The function is currently defined as
> function(biastype = symmetricBias(), normtype = NormType()){ 
+          new("asMSE", biastype = biastype, normtype = normtype) }
function (biastype = symmetricBias(), normtype = NormType()) 
{
    new("asMSE", biastype = biastype, normtype = normtype)
}
> 
> 
> 
> cleanEx()
> nameEx("asSemivar-class")
> ### * asSemivar-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asSemivar-class
> ### Title: Semivariance Risk Type
> ### Aliases: asSemivar-class sign,asSemivar-method sign<-,asSemivar-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> asSemivar()
An object of class "asSemivar" 
risk type:	 asymptotic Semivariance 
> 
> 
> 
> cleanEx()
> nameEx("asSemivar")
> ### * asSemivar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asSemivar
> ### Title: Generating function for asSemivar-class
> ### Aliases: asSemivar
> ### Keywords: robust
> 
> ### ** Examples
> 
> asSemivar()
An object of class "asSemivar" 
risk type:	 asymptotic Semivariance 
> 
> 
> 
> 
> cleanEx()
> nameEx("asUnOvShoot-class")
> ### * asUnOvShoot-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asUnOvShoot-class
> ### Title: Asymptotic under-/overshoot probability
> ### Aliases: asUnOvShoot-class width width,asUnOvShoot-method
> ###   show,asUnOvShoot-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("asUnOvShoot")
An object of class "asUnOvShoot" 
risk type:	 asymptotic under-/overshoot probability 
width:	  
> 
> 
> 
> cleanEx()
> nameEx("asUnOvShoot")
> ### * asUnOvShoot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asUnOvShoot
> ### Title: Generating function for asUnOvShoot-class
> ### Aliases: asUnOvShoot
> ### Keywords: robust
> 
> ### ** Examples
> 
> asUnOvShoot()
An object of class "asUnOvShoot" 
risk type:	 asymptotic under-/overshoot probability 
width:	 1.96 
> 
> ## The function is currently defined as
> function(width = 1.960, biastype = symmetricBias()){ 
+      new("asUnOvShoot", width = width, biastype = biastype) }
function (width = 1.96, biastype = symmetricBias()) 
{
    new("asUnOvShoot", width = width, biastype = biastype)
}
> 
> 
> 
> cleanEx()
> nameEx("asymmetricBias-class")
> ### * asymmetricBias-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asymmetricBias-class
> ### Title: asymmetric Bias Type
> ### Aliases: asymmetricBias-class nu,asymmetricBias-method
> ###   nu<-,asymmetricBias-method nu nu<-
> ### Keywords: classes
> 
> ### ** Examples
> 
> asymmetricBias()
An object of class "asymmetricBias"
Slot "nu":
[1] 1 1

Slot "name":
[1] "asymmetric Bias"

> ## The function is currently defined as
> function(){ new("asymmetricBias", name = "asymmetric Bias", nu = c(1,1)) }
function () 
{
    new("asymmetricBias", name = "asymmetric Bias", nu = c(1, 
        1))
}
> 
> aB <- asymmetricBias()
> nu(aB)
[1] 1 1
> try(nu(aB) <- -2) ## error
Error in `nu<-`(`*tmp*`, value = -2) : 
  Left value has to be in (0,1]x(0,1] with maximum 1
> nu(aB) <- c(0.3,1)
> 
> 
> 
> cleanEx()
> nameEx("asymmetricBias")
> ### * asymmetricBias
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: asymmetricBias
> ### Title: Generating function for asymmetricBias-class
> ### Aliases: asymmetricBias
> ### Keywords: robust
> 
> ### ** Examples
> 
> asymmetricBias()
An object of class "asymmetricBias"
Slot "nu":
[1] 1 1

Slot "name":
[1] "asymmetric Bias"

> 
> ## The function is currently defined as
> function(){ new("asymmetricBias", name = "asymmetric Bias", nu = c(1,1)) }
function () 
{
    new("asymmetricBias", name = "asymmetric Bias", nu = c(1, 
        1))
}
> 
> 
> 
> cleanEx()
> nameEx("checkL2deriv")
> ### * checkL2deriv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkL2deriv
> ### Title: Generic function for checking L2-derivatives
> ### Aliases: checkL2deriv print.relMatrix
> ### Keywords: models
> 
> ### ** Examples
> 
> F1 <- new("L2ParamFamily")
> checkL2deriv(F1)
precision of centering:	 0 
precision of Fisher information:
           [,1]
[1,] -5.794e-06
precision of Fisher information - relativ error [%]:
     [,1]     
[1,] -5.79e-04
condition of Fisher information:
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("confint-methods")
> ### * confint-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: confint-methods
> ### Title: Methods for function confint in Package 'distrMod'
> ### Aliases: confint-methods confint confint,ANY,missing-method
> ###   confint,Estimate,missing-method confint,mle,missing-method
> ###   confint,profile.mle,missing-method
> ### Keywords: models
> 
> ### ** Examples
> 
> ## for signature ANY examples confer stats::confint
> ## (empirical) Data
> x <- rgamma(50, scale = 0.5, shape = 3)
> 
> ## parametric family of probability measures
> G <- GammaFamily(scale = 1, shape = 2)
> 
> ## Maximum likelihood estimator
> res <- MLEstimator(x = x, ParamFamily = G)
> confint(res)
A[n] asymptotic (CLT-based) confidence interval:
          2.5 %    97.5 %
scale 0.2047574 0.4792587
shape 2.5295729 5.5909984
> 
> ### for comparison:
> require(MASS)
> (res1 <- fitdistr(x, "gamma"))
Warning in densfun(x, parm[1], parm[2], ...) : NaNs produced
     shape       rate   
  4.0606867   2.9242396 
 (0.7810673) (0.5987423)
> ## add a convenient (albeit wrong)
> ## S3-method for vcov:
> ## --- wrong as in general cov-matrix
> ##     will not be diagonal
> ## but for conf-interval this does
> ## not matter...
> vcov.fitdistr <- function(object, ...){
+      v<-diag(object$sd^2)
+      rownames(v) <- colnames(v) <- names(object$estimate) 
+      v}
> 
> ## explicitely transforming to
> ## MASS parametrization:
> mtrafo <- function(x){
+      nms0 <- names(c(main(param(G)),nuisance(param(G))))
+      nms <- c("shape","rate")
+      fval0 <- c(x[2], 1/x[1])
+      names(fval0) <- nms
+      mat0 <- matrix( c(0, -1/x[1]^2, 1, 0), nrow = 2, ncol = 2,
+                      dimnames = list(nms,nms0))                          
+      list(fval = fval0, mat = mat0)}
> 
> G2 <- G
> trafo(G2) <- mtrafo
> res2 <- MLEstimator(x = x, ParamFamily = G2)
> 
> old<-getdistrModOption("show.details")
> distrModoptions("show.details" = "minimal")
> res
Evaluations of Maximum likelihood estimate:
-------------------------------------------
     scale        shape   
  0.34200800   4.06028564 
 (0.07002713) (0.78099026)
> res1
     shape       rate   
  4.0606867   2.9242396 
 (0.7810673) (0.5987423)
> res2
Evaluations of Maximum likelihood estimate:
-------------------------------------------
     shape       rate   
  4.0602856   2.9239082 
 (0.7809903) (0.5986786)
> confint(res)
A[n] asymptotic (CLT-based) confidence interval:
          2.5 %    97.5 %
scale 0.2047574 0.4792587
shape 2.5295729 5.5909984
> confint(res1)
         2.5 %   97.5 %
shape 2.529823 5.591550
rate  1.750726 4.097753
> confint(res2)
A[n] asymptotic (CLT-based) confidence interval:
         2.5 %   97.5 %
shape 2.529573 5.590998
rate  1.750520 4.097297
> confint(res,level=0.99)
A[n] asymptotic (CLT-based) confidence interval:
          0.5 %    99.5 %
scale 0.1616301 0.5223859
shape 2.0485880 6.0719832
> distrModoptions("show.details" = old)
>  
> 
> 
> 
> cleanEx()
> nameEx("distrModMASK")
> ### * distrModMASK
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: distrModMASK
> ### Title: Masking of/by other functions in package "distrMod"
> ### Aliases: distrModMASK MASKING
> ### Keywords: programming distribution documentation
> 
> ### ** Examples
> 
> distrModMASK()
######################################################################
#  On masking of and by other functions in package "distrMod"       
######################################################################

Attention:

*** intentional masking: ***

To be able to use the same symbol for objects of S4-classes 'Estimate',
we intentionally mask the following function[s] --- however this/these 
function[s] may still be used in exactly the same way as before 
masking:

+confint()    (package "stats")
> 
> 
> 
> cleanEx()
> nameEx("distrModOptions")
> ### * distrModOptions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: distrModOptions
> ### Title: Function to change the global variables of the package
> ###   'distrMod'
> ### Aliases: distrModOptions getdistrModOption distrModoptions show.details
> ### Keywords: misc distribution
> 
> ### ** Examples
> 
> distrModoptions()
$show.details
[1] "minimal"

> distrModoptions("show.details")
$show.details
[1] "minimal"

> distrModoptions("show.details" = "maximal")
> distrModOptions("show.details" = "minimal")
> # or
> getdistrModOption("show.details")
[1] "minimal"
> 
> 
> 
> cleanEx()
> nameEx("fiBias-class")
> ### * fiBias-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fiBias-class
> ### Title: Finite-sample Bias
> ### Aliases: fiBias-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("fiBias")
An object of class "fiBias" 
risk type:	 finite-sample bias 
> 
> 
> 
> cleanEx()
> nameEx("fiBias")
> ### * fiBias
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fiBias
> ### Title: Generating function for fiBias-class
> ### Aliases: fiBias
> ### Keywords: robust
> 
> ### ** Examples
> 
> fiBias()
An object of class "fiBias" 
risk type:	 finite-sample bias 
> 
> ## The function is currently defined as
> function(){ new("fiBias") }
function () 
{
    new("fiBias")
}
> 
> 
> 
> cleanEx()
> nameEx("fiCov-class")
> ### * fiCov-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fiCov-class
> ### Title: Finite-sample covariance
> ### Aliases: fiCov-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("fiCov")
An object of class "fiCov" 
risk type:	 finite-sample covariance 
> 
> 
> 
> cleanEx()
> nameEx("fiCov")
> ### * fiCov
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fiCov
> ### Title: Generating function for fiCov-class
> ### Aliases: fiCov
> ### Keywords: robust
> 
> ### ** Examples
> 
> fiCov()
An object of class "fiCov" 
risk type:	 finite-sample covariance 
> 
> ## The function is currently defined as
> function(){ new("fiCov") }
function () 
{
    new("fiCov")
}
> 
> 
> 
> cleanEx()
> nameEx("fiHampel-class")
> ### * fiHampel-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fiHampel-class
> ### Title: Finite-sample Hampel risk
> ### Aliases: fiHampel-class bound,fiHampel-method show,fiHampel-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("fiHampel")
An object of class "fiHampel" 
risk type:	 finite-sample variance for given bias bound 
bound:	 Inf 
> 
> 
> 
> cleanEx()
> nameEx("fiHampel")
> ### * fiHampel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fiHampel
> ### Title: Generating function for fiHampel-class
> ### Aliases: fiHampel
> ### Keywords: robust
> 
> ### ** Examples
> 
> fiHampel()
An object of class "fiHampel" 
risk type:	 finite-sample variance for given bias bound 
bound:	 Inf 
> 
> ## The function is currently defined as
> function(bound = Inf){ new("fiHampel", bound = bound) }
function (bound = Inf) 
{
    new("fiHampel", bound = bound)
}
> 
> 
> 
> cleanEx()
> nameEx("fiMSE-class")
> ### * fiMSE-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fiMSE-class
> ### Title: Finite-sample mean square error
> ### Aliases: fiMSE-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("fiMSE")
An object of class "fiMSE" 
risk type:	 finite-sample mean square error 
> 
> 
> 
> cleanEx()
> nameEx("fiMSE")
> ### * fiMSE
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fiMSE
> ### Title: Generating function for fiMSE-class
> ### Aliases: fiMSE
> ### Keywords: robust
> 
> ### ** Examples
> 
> fiMSE()
An object of class "fiMSE" 
risk type:	 finite-sample mean square error 
> 
> ## The function is currently defined as
> function(){ new("fiMSE") }
function () 
{
    new("fiMSE")
}
> 
> 
> 
> cleanEx()
> nameEx("fiUnOvShoot-class")
> ### * fiUnOvShoot-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fiUnOvShoot-class
> ### Title: Finite-sample under-/overshoot probability
> ### Aliases: fiUnOvShoot-class width,fiUnOvShoot-method
> ###   show,fiUnOvShoot-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("fiUnOvShoot")
An object of class "fiUnOvShoot" 
risk type:	 finite-sample under-/overshoot probability 
width:	  
> 
> 
> 
> cleanEx()
> nameEx("fiUnOvShoot")
> ### * fiUnOvShoot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fiUnOvShoot
> ### Title: Generating function for fiUnOvShoot-class
> ### Aliases: fiUnOvShoot
> ### Keywords: robust
> 
> ### ** Examples
> 
> fiUnOvShoot()
An object of class "fiUnOvShoot" 
risk type:	 finite-sample under-/overshoot probability 
width:	 1.96 
> 
> ## The function is currently defined as
> function(width = 1.960){ new("fiUnOvShoot", width = width) }
function (width = 1.96) 
{
    new("fiUnOvShoot", width = width)
}
> 
> 
> 
> cleanEx()
> nameEx("isKerAinKerB")
> ### * isKerAinKerB
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: isKerAinKerB
> ### Title: isKerAinKerB
> ### Aliases: isKerAinKerB
> ### Keywords: algebra array
> 
> ### ** Examples
> 
> ma <- cbind(1,1,c(1,1,7))
> D <- t(ma %*% c(0,1,-1))
> ## IGNORE_RDIFF_BEGIN
> ## note that results may vary according to BLAS
> isKerAinKerB(D,ma)
[1] FALSE
> isKerAinKerB(ma,D)
[1] TRUE
> ## IGNORE_RDIFF_END
> 
> 
> 
> cleanEx()
> nameEx("negativeBias")
> ### * negativeBias
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: negativeBias
> ### Title: Generating function for onesidedBias-class
> ### Aliases: negativeBias
> ### Keywords: robust
> 
> ### ** Examples
> 
> negativeBias()
An object of class "onesidedBias"
Slot "sign":
[1] -1

Slot "name":
[1] "negative Bias"

> 
> ## The function is currently defined as
> function(){ new("onesidedBias", name = "negative Bias", sign = -1) }
function () 
{
    new("onesidedBias", name = "negative Bias", sign = -1)
}
> 
> 
> 
> cleanEx()
> nameEx("norms")
> ### * norms
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: norm
> ### Title: Norm functions
> ### Aliases: EuclideanNorm QuadFormNorm
> ### Keywords: robust
> 
> ### ** Examples
> 
> mm <- matrix(rnorm(20),2,10)
> EuclideanNorm(mm)
 [1] 0.6528164 1.8008876 0.8841627 0.8847092 0.6517563 1.5612367 2.3001816
 [8] 1.1258280 0.9439751 1.0134708
> QuadFormNorm(mm, A = PosSemDefSymmMatrix(matrix(c(3,1,1,1),2,2)))
 [1] 0.9904392 1.4048565 0.6768996 1.4062882 0.8579981 2.8613179 2.9689119
 [8] 1.9228451 0.9279285 1.8306775
> 
> 
> 
> cleanEx()
> nameEx("onesidedBias-class")
> ### * onesidedBias-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: onesidedBias-class
> ### Title: onesided Bias Type
> ### Aliases: onesidedBias-class sign sign<- sign,onesidedBias-method
> ###   sign<-,onesidedBias-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> positiveBias()
An object of class "onesidedBias"
Slot "sign":
[1] 1

Slot "name":
[1] "positive Bias"

> ## The function is currently defined as
> function(){ new("onesidedBias", name = "positive Bias", sign = 1) }
function () 
{
    new("onesidedBias", name = "positive Bias", sign = 1)
}
> 
> negativeBias()
An object of class "onesidedBias"
Slot "sign":
[1] -1

Slot "name":
[1] "negative Bias"

> ## The function is currently defined as
> function(){ new("onesidedBias", name = "negative Bias", sign = -1) }
function () 
{
    new("onesidedBias", name = "negative Bias", sign = -1)
}
> 
> pB <- positiveBias()
> sign(pB)
[1] 1
> try(sign(pB) <- -2) ## error
Error in `sign<-`(`*tmp*`, value = -2) : Left value has to be +-1
> sign(pB) <- -1
> 
> 
> 
> cleanEx()
> nameEx("positiveBias")
> ### * positiveBias
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: positiveBias
> ### Title: Generating function for onesidedBias-class
> ### Aliases: positiveBias
> ### Keywords: robust
> 
> ### ** Examples
> 
> positiveBias()
An object of class "onesidedBias"
Slot "sign":
[1] 1

Slot "name":
[1] "positive Bias"

> 
> ## The function is currently defined as
> function(){ new("onesidedBias", name = "positive Bias", sign = 1) }
function () 
{
    new("onesidedBias", name = "positive Bias", sign = 1)
}
> 
> 
> 
> cleanEx()
> nameEx("print-methods")
> ### * print-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print-methods
> ### Title: Common 'print' Methods for S4 classes in Package 'distrMod'
> ### Aliases: print-methods print,ShowDetails-method
> ### Keywords: models
> 
> ### ** Examples
> 
> ## set options to maximal detailedness
> show.old <- getdistrModOption("show.details")
> distrModoptions("show.details" = "maximal")
> ## define a model
> NS <- NormLocationScaleFamily(mean=2, sd=3)
> ## generate data out of this situation
> x <- r(distribution(NS))(30)
> 
> ## want to estimate mu/sigma, sigma^2
> ## -> new trafo slot:
> trafo(NS) <- function(param){
+   mu <- param["mean"]
+   sd <- param["sd"]
+   fval <- c(mu/sd, sd^2)
+   nfval <- c("mu/sig", "sig^2")
+   names(fval) <- nfval
+   mat <- matrix(c(1/sd,0,-mu/sd^2,2*sd),2,2)
+   dimnames(mat) <- list(nfval,c("mean","sd"))
+   return(list(fval=fval, mat=mat))
+ }
> print(param(NS))
An object of class "ParamWithScaleFamParameter"
name:	location and scale
mean:	2
sd:	3
trafo:
function (param) 
{
    mu <- param["mean"]
    sd <- param["sd"]
    fval <- c(mu/sd, sd^2)
    nfval <- c("mu/sig", "sig^2")
    names(fval) <- nfval
    mat <- matrix(c(1/sd, 0, -mu/sd^2, 2 * sd), 2, 2)
    dimnames(mat) <- list(nfval, c("mean", "sd"))
    return(list(fval = fval, mat = mat))
}
<bytecode: 0x14981bb0>
> print(param(NS), show.details = "minimal")
An object of class "ParamWithScaleFamParameter"
name:	location and scale
mean:	2
sd:	3
> print(param(NS), show.details = "medium")
An object of class "ParamWithScaleFamParameter"
name:	location and scale
mean:	2
sd:	3
slot trafo is a non-trivial function
> ## Maximum likelihood estimator
> res <- MLEstimator(x = x, ParamFamily = NS)
> print(res) #equivalent to 'show(res)' or 'res'
Evaluations of Maximum likelihood estimate:
-------------------------------------------
An object of class "MLEstimate" 
generated by call
  MLEstimator(x = x, ParamFamily = NS)
samplesize:   30
estimate:
    mu/sig       sig^2  
  0.8244932   7.4297939 
 (0.2113366) (1.9183645)
asymptotic (co)variance (multiplied with samplesize):
          mu/sig      sig^2
mu/sig  1.339895  -6.125814
sig^2  -6.125814 110.403676
untransformed estimate:
     mean         sd    
  2.2473745   2.7257648 
 (0.4976543) (0.3518947)
asymptotic (co)variance of untransformed estimate (multiplied with samplesize):
         mean       sd
mean 7.429794 0.000000
sd   0.000000 3.714897
Transformation of main parameter:
function (param) 
{
    mu <- param["mean"]
    sd <- param["sd"]
    fval <- c(mu/sd, sd^2)
    nfval <- c("mu/sig", "sig^2")
    names(fval) <- nfval
    mat <- matrix(c(1/sd, 0, -mu/sd^2, 2 * sd), 2, 2)
    dimnames(mat) <- list(nfval, c("mean", "sd"))
    return(list(fval = fval, mat = mat))
}
<bytecode: 0x14981bb0>
Trafo / derivative matrix:
            mean         sd
mu/sig 0.3668695 -0.3024814
sig^2  0.0000000  5.4515297
Criterion:
negative log-likelihood 
               72.65063 
> print(res, digits = 4)
Evaluations of Maximum likelihood estimate:
-------------------------------------------
An object of class "MLEstimate" 
generated by call
  MLEstimator(x = x, ParamFamily = NS)
samplesize:   30
estimate:
   mu/sig    sig^2 
  0.8245    7.4298 
 (0.2113)  (1.9184)
asymptotic (co)variance (multiplied with samplesize):
       mu/sig   sig^2
mu/sig  1.340  -6.126
sig^2  -6.126 110.404
untransformed estimate:
    mean      sd  
  2.2474   2.7258 
 (0.4977) (0.3519)
asymptotic (co)variance of untransformed estimate (multiplied with samplesize):
     mean    sd
mean 7.43 0.000
sd   0.00 3.715
Transformation of main parameter:
function (param) 
{
    mu <- param["mean"]
    sd <- param["sd"]
    fval <- c(mu/sd, sd^2)
    nfval <- c("mu/sig", "sig^2")
    names(fval) <- nfval
    mat <- matrix(c(1/sd, 0, -mu/sd^2, 2 * sd), 2, 2)
    dimnames(mat) <- list(nfval, c("mean", "sd"))
    return(list(fval = fval, mat = mat))
}
<bytecode: 0x14981bb0>
Trafo / derivative matrix:
         mean      sd
mu/sig 0.3669 -0.3025
sig^2  0.0000  5.4515
Criterion:
negative log-likelihood 
                  72.65 
> print(res, show.details = "minimal")
Evaluations of Maximum likelihood estimate:
-------------------------------------------
    mu/sig       sig^2  
  0.8244932   7.4297939 
 (0.2113366) (1.9183645)
> print(res, show.details = "medium")
Evaluations of Maximum likelihood estimate:
-------------------------------------------
An object of class "MLEstimate" 
generated by call
  MLEstimator(x = x, ParamFamily = NS)
samplesize:   30
estimate:
    mu/sig       sig^2  
  0.8244932   7.4297939 
 (0.2113366) (1.9183645)
asymptotic (co)variance (multiplied with samplesize):
          mu/sig      sig^2
mu/sig  1.339895  -6.125814
sig^2  -6.125814 110.403676
Criterion:
negative log-likelihood 
               72.65063 
> distrModoptions("show.details" = show.old)
> 
> 
> 
> cleanEx()
> nameEx("qqplot")
> ### * qqplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: qqplot
> ### Title: Methods for Function qqplot in Package 'distrMod'
> ### Aliases: qqplot qqplot-methods qqplot,ANY,ProbFamily-method
> ###   qqplot,ANY,Estimate-method qqplot,ANY,UnivariateDistribution-method
> ### Keywords: hplot distribution
> 
> ### ** Examples
> 
> set.seed(123)
> x <- rnorm(40,mean=15,sd=30)
> qqplot(x, Chisq(df=15))
> NF <- NormLocationScaleFamily(mean=15, sd=30)
> qqplot(x, NF, with.lab=TRUE, which.Order=1:5, cex.lbs=1.3)
> mlE <- MLEstimator(x, NF)
> qqplot(x, mlE)
> 
> 
> 
> cleanEx()
> nameEx("returnlevelplot")
> ### * returnlevelplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: returnlevelplot
> ### Title: Methods for Function returnlevelplot in Package 'distrMod'
> ### Aliases: returnlevelplot returnlevelplot-methods
> ###   returnlevelplot,ANY,ProbFamily-method
> ###   returnlevelplot,ANY,UnivariateDistribution-method
> ###   returnlevelplot,ANY,Estimate-method
> ### Keywords: hplot distribution
> 
> ### ** Examples
> 
> set.seed(20190331)
> returnlevelplot(r(Norm(15,sqrt(30)))(40), Chisq(df=15))
> ### more could be seen after installing RobExtremes and ismev
> #
> 
> ## IGNORE_RDIFF_BEGIN
> ## IGNORE_RDIFF_END
> 
> 
> 
> cleanEx()
> nameEx("symmetricBias-class")
> ### * symmetricBias-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: symmetricBias-class
> ### Title: symmetric Bias Type
> ### Aliases: symmetricBias-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> symmetricBias()
An object of class "symmetricBias"
Slot "name":
[1] "symmetric Bias"

> ## The function is currently defined as
> function(){ new("symmetricBias", name = "symmetric Bias") }
function () 
{
    new("symmetricBias", name = "symmetric Bias")
}
> 
> 
> 
> cleanEx()
> nameEx("symmetricBias")
> ### * symmetricBias
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: symmetricBias
> ### Title: Generating function for symmetricBias-class
> ### Aliases: symmetricBias
> ### Keywords: robust
> 
> ### ** Examples
> 
> symmetricBias()
An object of class "symmetricBias"
Slot "name":
[1] "symmetric Bias"

> 
> ## The function is currently defined as
> function(){ new("symmetricBias", name = "symmetric Bias") }
function () 
{
    new("symmetricBias", name = "symmetric Bias")
}
> 
> 
> 
> cleanEx()
> nameEx("trAsCov-class")
> ### * trAsCov-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trAsCov-class
> ### Title: Trace of asymptotic covariance
> ### Aliases: trAsCov-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("trAsCov")
An object of class "trAsCov" 
risk type:	 trace of asymptotic covariance 
> 
> 
> 
> cleanEx()
> nameEx("trAsCov")
> ### * trAsCov
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trAsCov
> ### Title: Generating function for trAsCov-class
> ### Aliases: trAsCov
> ### Keywords: robust
> 
> ### ** Examples
> 
> trAsCov()
An object of class "trAsCov" 
risk type:	 trace of asymptotic covariance 
> 
> ## The function is currently defined as
> function(){ new("trAsCov") }
function () 
{
    new("trAsCov")
}
> 
> 
> 
> cleanEx()
> nameEx("trFiCov-class")
> ### * trFiCov-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trFiCov-class
> ### Title: Trace of finite-sample covariance
> ### Aliases: trFiCov-class
> ### Keywords: classes
> 
> ### ** Examples
> 
> new("trFiCov")
An object of class "trFiCov" 
risk type:	 trace of finite-sample covariance 
> 
> 
> 
> cleanEx()
> nameEx("trFiCov")
> ### * trFiCov
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trFiCov
> ### Title: Generating function for trFiCov-class
> ### Aliases: trFiCov
> ### Keywords: robust
> 
> ### ** Examples
> 
> trFiCov()
An object of class "trFiCov" 
risk type:	 trace of finite-sample covariance 
> 
> ## The function is currently defined as
> function(){ new("trFiCov") }
function () 
{
    new("trFiCov")
}
> 
> 
> 
> cleanEx()
> nameEx("trafo-methods")
> ### * trafo-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trafo-methods
> ### Title: Methods for function trafo in Package 'distrMod'
> ### Aliases: trafo-methods trafo trafo,Estimate,missing-method
> ###   trafo,Estimate,ParamFamParameter-method
> ###   trafo,ParamFamParameter,missing-method
> ###   trafo,ParamWithScaleAndShapeFamParameter,missing-method
> ###   trafo,ParamFamily,missing-method
> ###   trafo,ParamFamily,ParamFamParameter-method trafo.fct
> ###   trafo.fct-methods trafo.fct,ParamFamily-method trafo<-
> ###   trafo<-,ParamFamParameter-method trafo<-,ParamFamily-method
> ### Keywords: models
> 
> ### ** Examples
> 
> ## Gaussian location and scale
> NS <- NormLocationScaleFamily(mean=2, sd=3)
> ## generate data out of this situation
> x <- r(distribution(NS))(30)
> 
> ## want to estimate mu/sigma, sigma^2
> ## -> new trafo slot:
> trafo(NS) <- function(param){
+   mu <- param["mean"]
+   sd <- param["sd"]
+   fval <- c(mu/sd, sd^2)
+   nfval <- c("mu/sig", "sig^2")
+   names(fval) <- nfval
+   mat <- matrix(c(1/sd,0,-mu/sd^2,2*sd),2,2)
+   dimnames(mat) <- list(nfval,c("mean","sd"))
+   return(list(fval=fval, mat=mat))
+ }
> 
> ## Maximum likelihood estimator
> (res <- MLEstimator(x = x, ParamFamily = NS))
Evaluations of Maximum likelihood estimate:
-------------------------------------------
    mu/sig       sig^2  
  0.8244932   7.4297939 
 (0.2113366) (1.9183645)
> ## confidence interval
>  confint(res)
A[n] asymptotic (CLT-based) confidence interval:
           2.5 %    97.5 %
mu/sig 0.4102811  1.238705
sig^2  3.6698685 11.189719
> 
> 
> 
> 
> cleanEx()
> nameEx("trafoEst")
> ### * trafoEst
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trafoEst
> ### Title: Function trafoEst in Package 'distrMod'
> ### Aliases: trafoEst
> ### Keywords: models
> 
> ### ** Examples
> 
> ## Gaussian location and scale
> NS <- NormLocationScaleFamily(mean=2, sd=3)
> ## generate data out of this situation
> x <- r(distribution(NS))(30)
> 
> ## want to estimate mu/sigma, sigma^2
> ## -> without new trafo slot:
> mtrafo <- function(param){
+   mu <- param["mean"]
+   sd <- param["sd"]
+   fval <- c(mu/sd, sd^2)
+   nfval <- c("mu/sig", "sig^2")
+   names(fval) <- nfval
+   mat <- matrix(c(1/sd,0,-mu/sd^2,2*sd),2,2)
+   dimnames(mat) <- list(nfval,c("mean","sd"))
+   return(list(fval=fval, mat=mat))
+ }
> 
> ## Maximum likelihood estimator in the original problem
> res0 <- MLEstimator(x = x, ParamFamily = NS)
> ## transformation
> res <- trafoEst(mtrafo, res0)
> ## confidence interval
>  confint(res)
A[n] asymptotic (CLT-based) confidence interval:
           2.5 %    97.5 %
mu/sig 0.4102811  1.238705
sig^2  3.6698685 11.189719
> 
> 
> 
> cleanEx()
> nameEx("validParameter-methods")
> ### * validParameter-methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: validParameter-methods
> ### Title: Methods for function validParameter in Package 'distrMod'
> ### Aliases: validParameter-methods validParameter
> ###   validParameter,ParamFamily-method validParameter,L2ScaleUnion-method
> ###   validParameter,L2ScaleFamily-method
> ###   validParameter,L2LocationFamily-method
> ###   validParameter,L2LocationScaleFamily-method
> ###   validParameter,BinomFamily-method validParameter,PoisFamily-method
> ###   validParameter,L2ScaleShapeUnion-method
> ### Keywords: models
> 
> ### ** Examples
> 
>  NS <- NormLocationScaleFamily()
>  validParameter(NS, c(scale=0.1, loc=2))
[1] TRUE
>  validParameter(NS, c(scale=-0.1, loc=2))
[1] FALSE
>  validParameter(NS, c(scale=0, loc=2))
[1] FALSE
>  validParameter(NS, c(mean=2, sd=2))
[1] TRUE
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  84.49 2.45 148.6 NA NA 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
